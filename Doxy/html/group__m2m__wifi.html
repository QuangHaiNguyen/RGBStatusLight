<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RGBStatusLight: WLAN</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RGBStatusLight
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__m2m__wifi.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#enumval-members">Enumerator</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">WLAN</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group___w_l_a_n_callbacks"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___w_l_a_n_callbacks.html">Callbacks</a></td></tr>
<tr class="memdesc:group___w_l_a_n_callbacks"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides detail on the available callbacks for the WLAN APIs. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___w_l_a_n_defines"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___w_l_a_n_defines.html">Defines</a></td></tr>
<tr class="memdesc:group___w_l_a_n_defines"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the macros and defines used by the WLAN APIs. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___w_l_a_n_enums"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___w_l_a_n_enums.html">Enumerations and Typedefs</a></td></tr>
<tr class="memdesc:group___w_l_a_n_enums"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the enums and Data Structures used by the WLAN APIs. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___w_l_a_n_a_p_i"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___w_l_a_n_a_p_i.html">WLAN Functions</a></td></tr>
<tr class="memdesc:group___w_l_a_n_a_p_i"><td class="mdescLeft">&#160;</td><td class="mdescRight">Here are listed all the functions that implement the WLAN APIs. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___v_e_r_s_i_o_n"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_e_r_s_i_o_n.html">Version</a></td></tr>
<tr class="memdesc:group___v_e_r_s_i_o_n"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes the APIs for reading the version information of the WINC firmware. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga9055e2da0c384ac1fd8b790edce66141"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga9055e2da0c384ac1fd8b790edce66141">m2m_wifi_cb</a> (uint8_t u8OpCode, uint16_t u16DataSize, uint32_t u32Addr)</td></tr>
<tr class="memdesc:ga9055e2da0c384ac1fd8b790edce66141"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal WiFi callback function.  <a href="group__m2m__wifi.html#ga9055e2da0c384ac1fd8b790edce66141">More...</a><br /></td></tr>
<tr class="separator:ga9055e2da0c384ac1fd8b790edce66141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1dfd77b592cbe00ce1f8576178f40ec6"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga1dfd77b592cbe00ce1f8576178f40ec6">m2m_wifi_download_mode</a> (void)</td></tr>
<tr class="memdesc:ga1dfd77b592cbe00ce1f8576178f40ec6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepares the WINC before downloading any data (firmware, certificates, etc).  <a href="group__m2m__wifi.html#ga1dfd77b592cbe00ce1f8576178f40ec6">More...</a><br /></td></tr>
<tr class="separator:ga1dfd77b592cbe00ce1f8576178f40ec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66f5bf5f84f898bdd4453f2717a3deb5"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga66f5bf5f84f898bdd4453f2717a3deb5">m2m_wifi_init</a> (<a class="el" href="structtstr_wifi_init_param.html">tstrWifiInitParam</a> *pWifiInitParam)</td></tr>
<tr class="memdesc:ga66f5bf5f84f898bdd4453f2717a3deb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous API to initialize the WINC driver.  <a href="group__m2m__wifi.html#ga66f5bf5f84f898bdd4453f2717a3deb5">More...</a><br /></td></tr>
<tr class="separator:ga66f5bf5f84f898bdd4453f2717a3deb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga748dfce4572adf510387302540c84ff0"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga748dfce4572adf510387302540c84ff0">m2m_wifi_deinit</a> (void *pVArg)</td></tr>
<tr class="memdesc:ga748dfce4572adf510387302540c84ff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous API to de-initialize the WINC driver and host interface.  <a href="group__m2m__wifi.html#ga748dfce4572adf510387302540c84ff0">More...</a><br /></td></tr>
<tr class="separator:ga748dfce4572adf510387302540c84ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12005142de3d7b4aee1b7091720715fe"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga12005142de3d7b4aee1b7091720715fe">m2m_wifi_init_hold</a> (void)</td></tr>
<tr class="memdesc:ga12005142de3d7b4aee1b7091720715fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">First part of <a class="el" href="group__m2m__wifi.html#ga66f5bf5f84f898bdd4453f2717a3deb5">m2m_wifi_init</a>, up to the point of initializing SPI for flash access.  <a href="group__m2m__wifi.html#ga12005142de3d7b4aee1b7091720715fe">More...</a><br /></td></tr>
<tr class="separator:ga12005142de3d7b4aee1b7091720715fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3d21bf9d8318d038bfa6a5063a8e278"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#gaf3d21bf9d8318d038bfa6a5063a8e278">m2m_wifi_init_start</a> (<a class="el" href="structtstr_wifi_init_param.html">tstrWifiInitParam</a> *pWifiInitParam)</td></tr>
<tr class="memdesc:gaf3d21bf9d8318d038bfa6a5063a8e278"><td class="mdescLeft">&#160;</td><td class="mdescRight">Second part of <a class="el" href="group__m2m__wifi.html#ga66f5bf5f84f898bdd4453f2717a3deb5">m2m_wifi_init</a>, continuing from where <a class="el" href="group__m2m__wifi.html#ga12005142de3d7b4aee1b7091720715fe">m2m_wifi_init_hold</a> left off.  <a href="group__m2m__wifi.html#gaf3d21bf9d8318d038bfa6a5063a8e278">More...</a><br /></td></tr>
<tr class="separator:gaf3d21bf9d8318d038bfa6a5063a8e278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae397199d8523f172b33309b82c34c2af"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#gae397199d8523f172b33309b82c34c2af">m2m_wifi_handle_events</a> (void *pVArg)</td></tr>
<tr class="memdesc:gae397199d8523f172b33309b82c34c2af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous M2M event handler function.  <a href="group__m2m__wifi.html#gae397199d8523f172b33309b82c34c2af">More...</a><br /></td></tr>
<tr class="separator:gae397199d8523f172b33309b82c34c2af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7667a375fd3c9ffa26566507b256f0c1"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga7667a375fd3c9ffa26566507b256f0c1">m2m_wifi_send_crl</a> (<a class="el" href="structtstr_tls_crl_info.html">tstrTlsCrlInfo</a> *pCRL)</td></tr>
<tr class="memdesc:ga7667a375fd3c9ffa26566507b256f0c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous API that notifies the WINC with the Certificate Revocation List.  <a href="group__m2m__wifi.html#ga7667a375fd3c9ffa26566507b256f0c1">More...</a><br /></td></tr>
<tr class="separator:ga7667a375fd3c9ffa26566507b256f0c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a9101bbe14718ef475e6085bafaf15e"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga2a9101bbe14718ef475e6085bafaf15e">m2m_wifi_delete_sc</a> (char *pcSsid, uint8_t u8SsidLen)</td></tr>
<tr class="memdesc:ga2a9101bbe14718ef475e6085bafaf15e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous API that deletes connection credentials (PSK, WEP key, 802.1X password) from WINC flash. Either deletes all credentials, or for a specific SSID.  <a href="group__m2m__wifi.html#ga2a9101bbe14718ef475e6085bafaf15e">More...</a><br /></td></tr>
<tr class="separator:ga2a9101bbe14718ef475e6085bafaf15e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga739abd39f7befa0da7bcea564a726141"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga739abd39f7befa0da7bcea564a726141">m2m_wifi_default_connect</a> (void)</td></tr>
<tr class="memdesc:ga739abd39f7befa0da7bcea564a726141"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous API that attempts to reconnect to the last-associated access point.  <a href="group__m2m__wifi.html#ga739abd39f7befa0da7bcea564a726141">More...</a><br /></td></tr>
<tr class="separator:ga739abd39f7befa0da7bcea564a726141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d684fd730f5175c281f3ac7a2b4eafa"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga8d684fd730f5175c281f3ac7a2b4eafa">m2m_wifi_connect_open</a> (<a class="el" href="group___w_l_a_n_enums.html#ga5669e8f0b3b645d5ece2519a33cf8c2c">tenuCredStoreOption</a> enuCredStoreOption, <a class="el" href="structtstr_network_id.html">tstrNetworkId</a> *pstrNetworkId)</td></tr>
<tr class="memdesc:ga8d684fd730f5175c281f3ac7a2b4eafa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous API to connect to an access point using open authentication.  <a href="group__m2m__wifi.html#ga8d684fd730f5175c281f3ac7a2b4eafa">More...</a><br /></td></tr>
<tr class="separator:ga8d684fd730f5175c281f3ac7a2b4eafa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf276c05ac4568cabafe9e0cf3861b154"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#gaf276c05ac4568cabafe9e0cf3861b154">m2m_wifi_connect_wep</a> (<a class="el" href="group___w_l_a_n_enums.html#ga5669e8f0b3b645d5ece2519a33cf8c2c">tenuCredStoreOption</a> enuCredStoreOption, <a class="el" href="structtstr_network_id.html">tstrNetworkId</a> *pstrNetworkId, <a class="el" href="structtstr_auth_wep.html">tstrAuthWep</a> *pstrAuthWep)</td></tr>
<tr class="memdesc:gaf276c05ac4568cabafe9e0cf3861b154"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous API to connect to an access point using WEP authentication.  <a href="group__m2m__wifi.html#gaf276c05ac4568cabafe9e0cf3861b154">More...</a><br /></td></tr>
<tr class="separator:gaf276c05ac4568cabafe9e0cf3861b154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa131b2fb19e32077923852539b807a84"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#gaa131b2fb19e32077923852539b807a84">m2m_wifi_connect_psk</a> (<a class="el" href="group___w_l_a_n_enums.html#ga5669e8f0b3b645d5ece2519a33cf8c2c">tenuCredStoreOption</a> enuCredStoreOption, <a class="el" href="structtstr_network_id.html">tstrNetworkId</a> *pstrNetworkId, <a class="el" href="structtstr_auth_psk.html">tstrAuthPsk</a> *pstrAuthPsk)</td></tr>
<tr class="memdesc:gaa131b2fb19e32077923852539b807a84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous API to connect to an access point using WPA(2) PSK authentication.  <a href="group__m2m__wifi.html#gaa131b2fb19e32077923852539b807a84">More...</a><br /></td></tr>
<tr class="separator:gaa131b2fb19e32077923852539b807a84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bdfa38e51644e958d866d5495fe8a98"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga8bdfa38e51644e958d866d5495fe8a98">m2m_wifi_connect_1x_mschap2</a> (<a class="el" href="group___w_l_a_n_enums.html#ga5669e8f0b3b645d5ece2519a33cf8c2c">tenuCredStoreOption</a> enuCredStoreOption, <a class="el" href="structtstr_network_id.html">tstrNetworkId</a> *pstrNetworkId, <a class="el" href="structtstr_auth1x_mschap2.html">tstrAuth1xMschap2</a> *pstrAuth1xMschap2)</td></tr>
<tr class="memdesc:ga8bdfa38e51644e958d866d5495fe8a98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous API to connect to an access point using WPA(2) Enterprise authentication with MS-CHAP-V2 credentials.  <a href="group__m2m__wifi.html#ga8bdfa38e51644e958d866d5495fe8a98">More...</a><br /></td></tr>
<tr class="separator:ga8bdfa38e51644e958d866d5495fe8a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b22373211fefea8a547f28f27f4a402"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga5b22373211fefea8a547f28f27f4a402">m2m_wifi_connect_1x_tls</a> (<a class="el" href="group___w_l_a_n_enums.html#ga5669e8f0b3b645d5ece2519a33cf8c2c">tenuCredStoreOption</a> enuCredStoreOption, <a class="el" href="structtstr_network_id.html">tstrNetworkId</a> *pstrNetworkId, <a class="el" href="structtstr_auth1x_tls.html">tstrAuth1xTls</a> *pstrAuth1xTls)</td></tr>
<tr class="memdesc:ga5b22373211fefea8a547f28f27f4a402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous API to connect to an access point using WPA(2) Enterprise authentication with MS-CHAP-V2 credentials.  <a href="group__m2m__wifi.html#ga5b22373211fefea8a547f28f27f4a402">More...</a><br /></td></tr>
<tr class="separator:ga5b22373211fefea8a547f28f27f4a402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39167bb6c3a20a24f46b387e7096d501"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga39167bb6c3a20a24f46b387e7096d501">m2m_wifi_connect</a> (char *pcSsid, uint8_t u8SsidLen, uint8_t u8SecType, void *pvAuthInfo, uint16_t u16Ch)</td></tr>
<tr class="memdesc:ga39167bb6c3a20a24f46b387e7096d501"><td class="mdescLeft">&#160;</td><td class="mdescRight">DEPRECATED in v19.6.1 - Kept only for legacy purposes.<br  />
 Legacy asynchronous API to request connection to a specified access point.  <a href="group__m2m__wifi.html#ga39167bb6c3a20a24f46b387e7096d501">More...</a><br /></td></tr>
<tr class="separator:ga39167bb6c3a20a24f46b387e7096d501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89df08f98aca47e8fb4c584d74d1bd3f"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga89df08f98aca47e8fb4c584d74d1bd3f">m2m_wifi_connect_sc</a> (char *pcSsid, uint8_t u8SsidLen, uint8_t u8SecType, void *pvAuthInfo, uint16_t u16Ch, uint8_t u8NoSaveCred)</td></tr>
<tr class="memdesc:ga89df08f98aca47e8fb4c584d74d1bd3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">DEPRECATED in v19.6.1 - Kept only for legacy purposes.<br  />
 Legacy asynchronous API to request connection to a specific AP with the option to save credentials in Flash.  <a href="group__m2m__wifi.html#ga89df08f98aca47e8fb4c584d74d1bd3f">More...</a><br /></td></tr>
<tr class="separator:ga89df08f98aca47e8fb4c584d74d1bd3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6949ee7b771bfb0c4e0f160b98dadf7b"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga6949ee7b771bfb0c4e0f160b98dadf7b">m2m_wifi_disconnect</a> (void)</td></tr>
<tr class="memdesc:ga6949ee7b771bfb0c4e0f160b98dadf7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous API to request disconnection from a network.  <a href="group__m2m__wifi.html#ga6949ee7b771bfb0c4e0f160b98dadf7b">More...</a><br /></td></tr>
<tr class="separator:ga6949ee7b771bfb0c4e0f160b98dadf7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdde655475346d6c5d5983c8e159246e"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#gacdde655475346d6c5d5983c8e159246e">m2m_wifi_start_provision_mode</a> (<a class="el" href="structtstr_m2_m_a_p_config.html">tstrM2MAPConfig</a> *pstrAPConfig, char *pcHttpServerDomainName, uint8_t bEnableHttpRedirect)</td></tr>
<tr class="memdesc:gacdde655475346d6c5d5983c8e159246e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous API for control of Wi-Fi provisioning functionality.  <a href="group__m2m__wifi.html#gacdde655475346d6c5d5983c8e159246e">More...</a><br /></td></tr>
<tr class="separator:gacdde655475346d6c5d5983c8e159246e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga150576e8996172d1ae24a7070eb527c3"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga150576e8996172d1ae24a7070eb527c3">m2m_wifi_start_provision_mode_ext</a> (<a class="el" href="structtstr_m2_m_a_p_mode_config.html">tstrM2MAPModeConfig</a> *pstrAPModeConfig, char *pcHttpServerDomainName, uint8_t bEnableHttpRedirect)</td></tr>
<tr class="memdesc:ga150576e8996172d1ae24a7070eb527c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous API for control of Wi-Fi provisioning functionality with extended options.  <a href="group__m2m__wifi.html#ga150576e8996172d1ae24a7070eb527c3">More...</a><br /></td></tr>
<tr class="separator:ga150576e8996172d1ae24a7070eb527c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga580bb659506b1c6d5c0f7c35f79f5386"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga580bb659506b1c6d5c0f7c35f79f5386">m2m_wifi_stop_provision_mode</a> (void)</td></tr>
<tr class="memdesc:ga580bb659506b1c6d5c0f7c35f79f5386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous API for terminating provisioning mode on the WINC.  <a href="group__m2m__wifi.html#ga580bb659506b1c6d5c0f7c35f79f5386">More...</a><br /></td></tr>
<tr class="separator:ga580bb659506b1c6d5c0f7c35f79f5386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe55ce43f9508f29eade37afa68c2bf2"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#gabe55ce43f9508f29eade37afa68c2bf2">m2m_wifi_get_connection_info</a> (void)</td></tr>
<tr class="memdesc:gabe55ce43f9508f29eade37afa68c2bf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous API for retrieving the WINC connection status.  <a href="group__m2m__wifi.html#gabe55ce43f9508f29eade37afa68c2bf2">More...</a><br /></td></tr>
<tr class="separator:gabe55ce43f9508f29eade37afa68c2bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cc2b80205ac21bd62102b24927788df"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga6cc2b80205ac21bd62102b24927788df">m2m_wifi_set_mac_address</a> (uint8_t au8MacAddress[6])</td></tr>
<tr class="memdesc:ga6cc2b80205ac21bd62102b24927788df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous API for assigning a MAC address to the WINC.  <a href="group__m2m__wifi.html#ga6cc2b80205ac21bd62102b24927788df">More...</a><br /></td></tr>
<tr class="separator:ga6cc2b80205ac21bd62102b24927788df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67de06e2707f6a56b62b1490c24f5a26"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga67de06e2707f6a56b62b1490c24f5a26">m2m_wifi_wps</a> (uint8_t u8TriggerType, const char *pcPinNumber)</td></tr>
<tr class="memdesc:ga67de06e2707f6a56b62b1490c24f5a26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous API to engage the WINC Wi-Fi Protected Setup (enrollee) function.  <a href="group__m2m__wifi.html#ga67de06e2707f6a56b62b1490c24f5a26">More...</a><br /></td></tr>
<tr class="separator:ga67de06e2707f6a56b62b1490c24f5a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0a66c1111e19f90cd3b9227cdd5d5b8"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#gaf0a66c1111e19f90cd3b9227cdd5d5b8">m2m_wifi_wps_disable</a> (void)</td></tr>
<tr class="memdesc:gaf0a66c1111e19f90cd3b9227cdd5d5b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous API that disables Wi-Fi Protected Setup mode in the WINC.  <a href="group__m2m__wifi.html#gaf0a66c1111e19f90cd3b9227cdd5d5b8">More...</a><br /></td></tr>
<tr class="separator:gaf0a66c1111e19f90cd3b9227cdd5d5b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9479ba2f53700434b8f4b31363ddfa0c"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga9479ba2f53700434b8f4b31363ddfa0c">m2m_wifi_enable_ap</a> (const <a class="el" href="structtstr_m2_m_a_p_config.html">tstrM2MAPConfig</a> *pstrM2MAPConfig)</td></tr>
<tr class="memdesc:ga9479ba2f53700434b8f4b31363ddfa0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous API to enable access point (AKA "hot-spot") mode on the WINC.  <a href="group__m2m__wifi.html#ga9479ba2f53700434b8f4b31363ddfa0c">More...</a><br /></td></tr>
<tr class="separator:ga9479ba2f53700434b8f4b31363ddfa0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9edfcc6247a767e2528efd23a39b700e"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga9edfcc6247a767e2528efd23a39b700e">m2m_wifi_enable_ap_ext</a> (const <a class="el" href="structtstr_m2_m_a_p_mode_config.html">tstrM2MAPModeConfig</a> *pstrM2MAPModeConfig)</td></tr>
<tr class="memdesc:ga9edfcc6247a767e2528efd23a39b700e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous API to enable access point (AKA "hot-spot") mode on the WINC IC with extended options.  <a href="group__m2m__wifi.html#ga9edfcc6247a767e2528efd23a39b700e">More...</a><br /></td></tr>
<tr class="separator:ga9edfcc6247a767e2528efd23a39b700e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacefe61650b1cb0727aa6ce77e5efd087"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#gacefe61650b1cb0727aa6ce77e5efd087">m2m_wifi_disable_ap</a> (void)</td></tr>
<tr class="memdesc:gacefe61650b1cb0727aa6ce77e5efd087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous API to disable access point mode on the WINC.  <a href="group__m2m__wifi.html#gacefe61650b1cb0727aa6ce77e5efd087">More...</a><br /></td></tr>
<tr class="separator:gacefe61650b1cb0727aa6ce77e5efd087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c4c223a4eb484298c3742d40eb3c2f7"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga6c4c223a4eb484298c3742d40eb3c2f7">m2m_wifi_set_static_ip</a> (<a class="el" href="structtstr_m2_m_i_p_config.html">tstrM2MIPConfig</a> *pstrStaticIPConf)</td></tr>
<tr class="memdesc:ga6c4c223a4eb484298c3742d40eb3c2f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous API to manually assign a (static) IP address to the WINC.  <a href="group__m2m__wifi.html#ga6c4c223a4eb484298c3742d40eb3c2f7">More...</a><br /></td></tr>
<tr class="separator:ga6c4c223a4eb484298c3742d40eb3c2f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee8e0e7b992d84bd0762dfbb48e6aaf7"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#gaee8e0e7b992d84bd0762dfbb48e6aaf7">m2m_wifi_enable_dhcp</a> (uint8_t u8DhcpEn)</td></tr>
<tr class="memdesc:gaee8e0e7b992d84bd0762dfbb48e6aaf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous function to control the DHCP client functionality within the WINC.  <a href="group__m2m__wifi.html#gaee8e0e7b992d84bd0762dfbb48e6aaf7">More...</a><br /></td></tr>
<tr class="separator:gaee8e0e7b992d84bd0762dfbb48e6aaf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf270d6f64b704d8a13358ddf4c7f21a9"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#gaf270d6f64b704d8a13358ddf4c7f21a9">m2m_wifi_set_scan_options</a> (<a class="el" href="structtstr_m2_m_scan_option.html">tstrM2MScanOption</a> *ptstrM2MScanOption)</td></tr>
<tr class="memdesc:gaf270d6f64b704d8a13358ddf4c7f21a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous API for configuring the behaviour of the WINC network scanning functions.  <a href="group__m2m__wifi.html#gaf270d6f64b704d8a13358ddf4c7f21a9">More...</a><br /></td></tr>
<tr class="separator:gaf270d6f64b704d8a13358ddf4c7f21a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f7cd8414e3725cae803b89c09b41bff"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga0f7cd8414e3725cae803b89c09b41bff">m2m_wifi_set_scan_region</a> (uint16_t u16ScanRegion)</td></tr>
<tr class="memdesc:ga0f7cd8414e3725cae803b89c09b41bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous API for configuring the regulatory restrictions that may affect the WINC scanning behaviour.  <a href="group__m2m__wifi.html#ga0f7cd8414e3725cae803b89c09b41bff">More...</a><br /></td></tr>
<tr class="separator:ga0f7cd8414e3725cae803b89c09b41bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39eab477f1dbb3b2a768d8a0fdc45b27"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga39eab477f1dbb3b2a768d8a0fdc45b27">m2m_wifi_request_scan</a> (uint8_t u8Ch)</td></tr>
<tr class="memdesc:ga39eab477f1dbb3b2a768d8a0fdc45b27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous API to request the WINC to scan for networks.  <a href="group__m2m__wifi.html#ga39eab477f1dbb3b2a768d8a0fdc45b27">More...</a><br /></td></tr>
<tr class="separator:ga39eab477f1dbb3b2a768d8a0fdc45b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7835becaa9fcc09485724904d06ef182"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga7835becaa9fcc09485724904d06ef182">m2m_wifi_request_scan_passive</a> (uint8_t u8Ch, uint16_t u16ScanTime)</td></tr>
<tr class="memdesc:ga7835becaa9fcc09485724904d06ef182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="group__m2m__wifi.html#ga39eab477f1dbb3b2a768d8a0fdc45b27">m2m_wifi_request_scan</a> but performs passive scanning instead of active scanning.  <a href="group__m2m__wifi.html#ga7835becaa9fcc09485724904d06ef182">More...</a><br /></td></tr>
<tr class="separator:ga7835becaa9fcc09485724904d06ef182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga113c7905d21a932de8c06f0af023c428"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga113c7905d21a932de8c06f0af023c428">m2m_wifi_request_scan_ssid_list</a> (uint8_t u8Ch, uint8_t *pu8Ssidlist)</td></tr>
<tr class="memdesc:ga113c7905d21a932de8c06f0af023c428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous Wi-Fi scan request on the given channel and the hidden scan list.  <a href="group__m2m__wifi.html#ga113c7905d21a932de8c06f0af023c428">More...</a><br /></td></tr>
<tr class="separator:ga113c7905d21a932de8c06f0af023c428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1638306107bf997ec4df62a473dba3b4"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga1638306107bf997ec4df62a473dba3b4">m2m_wifi_get_num_ap_found</a> (void)</td></tr>
<tr class="memdesc:ga1638306107bf997ec4df62a473dba3b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous function to retrieve the number of AP's found during the last scan operation.  <a href="group__m2m__wifi.html#ga1638306107bf997ec4df62a473dba3b4">More...</a><br /></td></tr>
<tr class="separator:ga1638306107bf997ec4df62a473dba3b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecfcbf84f283cd76de00a6e884f421fe"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#gaecfcbf84f283cd76de00a6e884f421fe">m2m_wifi_req_scan_result</a> (uint8_t u8Index)</td></tr>
<tr class="memdesc:gaecfcbf84f283cd76de00a6e884f421fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous API to request the information of an access point discovered via scanning.  <a href="group__m2m__wifi.html#gaecfcbf84f283cd76de00a6e884f421fe">More...</a><br /></td></tr>
<tr class="separator:gaecfcbf84f283cd76de00a6e884f421fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1219188caab32603e96662d6bd6fd46d"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga1219188caab32603e96662d6bd6fd46d">m2m_wifi_req_curr_rssi</a> (void)</td></tr>
<tr class="memdesc:ga1219188caab32603e96662d6bd6fd46d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous API to request the current Receive Signal Strength (RSSI) of the current connection.  <a href="group__m2m__wifi.html#ga1219188caab32603e96662d6bd6fd46d">More...</a><br /></td></tr>
<tr class="separator:ga1219188caab32603e96662d6bd6fd46d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fc47dc397a4e9d9213ec40f9ba2bb19"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga2fc47dc397a4e9d9213ec40f9ba2bb19">m2m_wifi_get_otp_mac_address</a> (uint8_t *pu8MacAddr, uint8_t *pu8IsValid)</td></tr>
<tr class="memdesc:ga2fc47dc397a4e9d9213ec40f9ba2bb19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous API to query the MAC address programmed into the WINC OTP memory.  <a href="group__m2m__wifi.html#ga2fc47dc397a4e9d9213ec40f9ba2bb19">More...</a><br /></td></tr>
<tr class="separator:ga2fc47dc397a4e9d9213ec40f9ba2bb19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00be821aaad96330c8472838c1b8570f"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga00be821aaad96330c8472838c1b8570f">m2m_wifi_get_mac_address</a> (uint8_t *pu8MacAddr)</td></tr>
<tr class="memdesc:ga00be821aaad96330c8472838c1b8570f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous API to retrieve the MAC address currently in use by the device.  <a href="group__m2m__wifi.html#ga00be821aaad96330c8472838c1b8570f">More...</a><br /></td></tr>
<tr class="separator:ga00be821aaad96330c8472838c1b8570f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38ba065f25bf5cc2bbd35d6498121192"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga38ba065f25bf5cc2bbd35d6498121192">m2m_wifi_set_sleep_mode</a> (uint8_t u8PsTyp, uint8_t u8BcastEn)</td></tr>
<tr class="memdesc:ga38ba065f25bf5cc2bbd35d6498121192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous API to set the power-save mode of the WINC.  <a href="group__m2m__wifi.html#ga38ba065f25bf5cc2bbd35d6498121192">More...</a><br /></td></tr>
<tr class="separator:ga38ba065f25bf5cc2bbd35d6498121192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae074746e383410f327d0fd56dc46b848"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#gae074746e383410f327d0fd56dc46b848">m2m_wifi_request_sleep</a> (uint32_t u32SlpReqTime)</td></tr>
<tr class="memdesc:gae074746e383410f327d0fd56dc46b848"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous API to place the WINC into sleep mode for a specified period of time.  <a href="group__m2m__wifi.html#gae074746e383410f327d0fd56dc46b848">More...</a><br /></td></tr>
<tr class="separator:gae074746e383410f327d0fd56dc46b848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac53a9e3e4cd24b318e4e3722c5afb4ed"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#gac53a9e3e4cd24b318e4e3722c5afb4ed">m2m_wifi_get_sleep_mode</a> (void)</td></tr>
<tr class="memdesc:gac53a9e3e4cd24b318e4e3722c5afb4ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous API to retrieve the current power save mode of the WINC.  <a href="group__m2m__wifi.html#gac53a9e3e4cd24b318e4e3722c5afb4ed">More...</a><br /></td></tr>
<tr class="separator:gac53a9e3e4cd24b318e4e3722c5afb4ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7c165141384ecd94e71c63c082b170a"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#gae7c165141384ecd94e71c63c082b170a">m2m_wifi_req_client_ctrl</a> (uint8_t u8Cmd)</td></tr>
<tr class="memdesc:gae7c165141384ecd94e71c63c082b170a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous command sending function to the PS Client.  <a href="group__m2m__wifi.html#gae7c165141384ecd94e71c63c082b170a">More...</a><br /></td></tr>
<tr class="separator:gae7c165141384ecd94e71c63c082b170a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac44423b48adee04e340a7acfa04e95d1"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#gac44423b48adee04e340a7acfa04e95d1">m2m_wifi_req_server_init</a> (uint8_t u8Ch)</td></tr>
<tr class="memdesc:gac44423b48adee04e340a7acfa04e95d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous function to initialize the PS Server.  <a href="group__m2m__wifi.html#gac44423b48adee04e340a7acfa04e95d1">More...</a><br /></td></tr>
<tr class="separator:gac44423b48adee04e340a7acfa04e95d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6298406d05df2a867a2c0f6fe412c563"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga6298406d05df2a867a2c0f6fe412c563">m2m_wifi_set_device_name</a> (uint8_t *pu8DeviceName, uint8_t u8DeviceNameLength)</td></tr>
<tr class="memdesc:ga6298406d05df2a867a2c0f6fe412c563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous API to set the Wi-Fi Direct "Device Name" of the WINC.  <a href="group__m2m__wifi.html#ga6298406d05df2a867a2c0f6fe412c563">More...</a><br /></td></tr>
<tr class="separator:ga6298406d05df2a867a2c0f6fe412c563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29af80f4f2d3bd510cb1f814ed8590d3"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga29af80f4f2d3bd510cb1f814ed8590d3">m2m_wifi_configure_sntp</a> (uint8_t *pu8NTPServerName, uint8_t u8NTPServerNameLength, <a class="el" href="group___w_l_a_n_enums.html#ga8eef709e17dc0454c9fd556f302766e2">tenuSNTPUseDHCP</a> enuUseDHCP)</td></tr>
<tr class="memdesc:ga29af80f4f2d3bd510cb1f814ed8590d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures what NTP server the SNTP client should use.  <a href="group__m2m__wifi.html#ga29af80f4f2d3bd510cb1f814ed8590d3">More...</a><br /></td></tr>
<tr class="separator:ga29af80f4f2d3bd510cb1f814ed8590d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa19969f83ad50c28d9bea07b2f4f0280"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#gaa19969f83ad50c28d9bea07b2f4f0280">m2m_wifi_set_lsn_int</a> (<a class="el" href="structtstr_m2m_lsn_int.html">tstrM2mLsnInt</a> *pstrM2mLsnInt)</td></tr>
<tr class="memdesc:gaa19969f83ad50c28d9bea07b2f4f0280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous API to set Wi-Fi listen interval for power save operation.  <a href="group__m2m__wifi.html#gaa19969f83ad50c28d9bea07b2f4f0280">More...</a><br /></td></tr>
<tr class="separator:gaa19969f83ad50c28d9bea07b2f4f0280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d817bd436735409766faca4021c06c9"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga5d817bd436735409766faca4021c06c9">m2m_wifi_send_ethernet_pkt</a> (uint8_t *pu8Packet, uint16_t u16PacketSize)</td></tr>
<tr class="memdesc:ga5d817bd436735409766faca4021c06c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous API to queue an Ethernet packet for transmission by the WINC.  <a href="group__m2m__wifi.html#ga5d817bd436735409766faca4021c06c9">More...</a><br /></td></tr>
<tr class="separator:ga5d817bd436735409766faca4021c06c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97cd0378aa47bc3039ab0e30c926155a"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga97cd0378aa47bc3039ab0e30c926155a">m2m_wifi_enable_sntp</a> (uint8_t u8Enable)</td></tr>
<tr class="memdesc:ga97cd0378aa47bc3039ab0e30c926155a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous API to enable or disable the native Simple Network Time Protocol(SNTP) client running on the WINC.  <a href="group__m2m__wifi.html#ga97cd0378aa47bc3039ab0e30c926155a">More...</a><br /></td></tr>
<tr class="separator:ga97cd0378aa47bc3039ab0e30c926155a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4055ecd51b8c38e427d9f418f1743712"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga4055ecd51b8c38e427d9f418f1743712">m2m_wifi_set_system_time</a> (uint32_t u32UTCSeconds)</td></tr>
<tr class="memdesc:ga4055ecd51b8c38e427d9f418f1743712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous function for setting the system time within the WINC.  <a href="group__m2m__wifi.html#ga4055ecd51b8c38e427d9f418f1743712">More...</a><br /></td></tr>
<tr class="separator:ga4055ecd51b8c38e427d9f418f1743712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57394f15ef7d7c5a273776870680b9c3"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga57394f15ef7d7c5a273776870680b9c3">m2m_wifi_get_system_time</a> (void)</td></tr>
<tr class="memdesc:ga57394f15ef7d7c5a273776870680b9c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous API to obtain the system time in use by the WINC.  <a href="group__m2m__wifi.html#ga57394f15ef7d7c5a273776870680b9c3">More...</a><br /></td></tr>
<tr class="separator:ga57394f15ef7d7c5a273776870680b9c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab40418aa14adc8ee037b1089ffb6449c"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#gab40418aa14adc8ee037b1089ffb6449c">m2m_wifi_set_cust_InfoElement</a> (uint8_t *pau8M2mCustInfoElement)</td></tr>
<tr class="memdesc:gab40418aa14adc8ee037b1089ffb6449c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous API to add or remove a user-defined Information Element.  <a href="group__m2m__wifi.html#gab40418aa14adc8ee037b1089ffb6449c">More...</a><br /></td></tr>
<tr class="separator:gab40418aa14adc8ee037b1089ffb6449c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad13438fd7ceb428310eb6abe9ba42fef"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#gad13438fd7ceb428310eb6abe9ba42fef">m2m_wifi_set_power_profile</a> (uint8_t u8PwrMode)</td></tr>
<tr class="memdesc:gad13438fd7ceb428310eb6abe9ba42fef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the power profile mode.  <a href="group__m2m__wifi.html#gad13438fd7ceb428310eb6abe9ba42fef">More...</a><br /></td></tr>
<tr class="separator:gad13438fd7ceb428310eb6abe9ba42fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadde88bb1e426f92e38c99fb32d96293d"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#gadde88bb1e426f92e38c99fb32d96293d">m2m_wifi_set_tx_power</a> (uint8_t u8TxPwrLevel)</td></tr>
<tr class="memdesc:gadde88bb1e426f92e38c99fb32d96293d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the TX power tenuM2mTxPwrLevel.  <a href="group__m2m__wifi.html#gadde88bb1e426f92e38c99fb32d96293d">More...</a><br /></td></tr>
<tr class="separator:gadde88bb1e426f92e38c99fb32d96293d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73ecacb3650558efb9a437443b0deaf5"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga73ecacb3650558efb9a437443b0deaf5">m2m_wifi_set_gain_table_idx</a> (uint8_t u8GainTableIdx)</td></tr>
<tr class="memdesc:ga73ecacb3650558efb9a437443b0deaf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the Gain table index corresponding to specific WiFi region.  <a href="group__m2m__wifi.html#ga73ecacb3650558efb9a437443b0deaf5">More...</a><br /></td></tr>
<tr class="separator:ga73ecacb3650558efb9a437443b0deaf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e86dfc3d6d3c7fdf540b42a1e6f0824"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga6e86dfc3d6d3c7fdf540b42a1e6f0824">m2m_wifi_enable_firmware_logs</a> (uint8_t u8Enable)</td></tr>
<tr class="memdesc:ga6e86dfc3d6d3c7fdf540b42a1e6f0824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or Disable logs in run time.  <a href="group__m2m__wifi.html#ga6e86dfc3d6d3c7fdf540b42a1e6f0824">More...</a><br /></td></tr>
<tr class="separator:ga6e86dfc3d6d3c7fdf540b42a1e6f0824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36ac9f33e8c7208e9ec6fd1a2b02f549"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga36ac9f33e8c7208e9ec6fd1a2b02f549">m2m_wifi_set_battery_voltage</a> (uint16_t u16BattVoltx100)</td></tr>
<tr class="memdesc:ga36ac9f33e8c7208e9ec6fd1a2b02f549"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the battery voltage to update the firmware calculations.  <a href="group__m2m__wifi.html#ga36ac9f33e8c7208e9ec6fd1a2b02f549">More...</a><br /></td></tr>
<tr class="separator:ga36ac9f33e8c7208e9ec6fd1a2b02f549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30347bdddc5fc20ebe28e7e40a1b847d"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga30347bdddc5fc20ebe28e7e40a1b847d">m2m_wifi_set_gains</a> (<a class="el" href="structtstr_m2m_wifi_gains_params.html">tstrM2mWifiGainsParams</a> *pstrM2mGain)</td></tr>
<tr class="memdesc:ga30347bdddc5fc20ebe28e7e40a1b847d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the chip PPA gain for 11b/11gn.  <a href="group__m2m__wifi.html#ga30347bdddc5fc20ebe28e7e40a1b847d">More...</a><br /></td></tr>
<tr class="separator:ga30347bdddc5fc20ebe28e7e40a1b847d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61307d612276cfaa10e3c5d95da59fdf"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga61307d612276cfaa10e3c5d95da59fdf">m2m_wifi_prng_get_random_bytes</a> (uint8_t *pu8PrngBuff, uint16_t u16PrngSize)</td></tr>
<tr class="memdesc:ga61307d612276cfaa10e3c5d95da59fdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous function for retrieving from the firmware a pseudo-random set of bytes.  <a href="group__m2m__wifi.html#ga61307d612276cfaa10e3c5d95da59fdf">More...</a><br /></td></tr>
<tr class="separator:ga61307d612276cfaa10e3c5d95da59fdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ac5925878de8a3b57c8287c2b10663d"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga6ac5925878de8a3b57c8287c2b10663d">m2m_wifi_conf_auto_rate</a> (<a class="el" href="structtstr_conf_auto_rate.html">tstrConfAutoRate</a> *pstrConfAutoRate)</td></tr>
<tr class="memdesc:ga6ac5925878de8a3b57c8287c2b10663d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures WLAN automatic TX rate adaptation algorithm.  <a href="group__m2m__wifi.html#ga6ac5925878de8a3b57c8287c2b10663d">More...</a><br /></td></tr>
<tr class="separator:ga6ac5925878de8a3b57c8287c2b10663d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb0fb11fb86774ba0c56982cf4d43fe0"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#gafb0fb11fb86774ba0c56982cf4d43fe0">m2m_wifi_enable_roaming</a> (uint8_t u8EnableDhcp)</td></tr>
<tr class="memdesc:gafb0fb11fb86774ba0c56982cf4d43fe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable WiFi STA roaming.  <a href="group__m2m__wifi.html#gafb0fb11fb86774ba0c56982cf4d43fe0">More...</a><br /></td></tr>
<tr class="separator:gafb0fb11fb86774ba0c56982cf4d43fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfae399c6a5bca4ff754cb57459d4de3"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#gacfae399c6a5bca4ff754cb57459d4de3">m2m_wifi_disable_roaming</a> (void)</td></tr>
<tr class="memdesc:gacfae399c6a5bca4ff754cb57459d4de3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable WiFi STA roaming.  <a href="group__m2m__wifi.html#gacfae399c6a5bca4ff754cb57459d4de3">More...</a><br /></td></tr>
<tr class="separator:gacfae399c6a5bca4ff754cb57459d4de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5372f7bc6a7bda4a40e0b9f979ed9a7f"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga5372f7bc6a7bda4a40e0b9f979ed9a7f">m2m_wifi_get_state</a> (void)</td></tr>
<tr class="memdesc:ga5372f7bc6a7bda4a40e0b9f979ed9a7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Wi-Fi state.  <a href="group__m2m__wifi.html#ga5372f7bc6a7bda4a40e0b9f979ed9a7f">More...</a><br /></td></tr>
<tr class="separator:ga5372f7bc6a7bda4a40e0b9f979ed9a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0ca8bc0a8c78acaa115ddb677f55401"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#gac0ca8bc0a8c78acaa115ddb677f55401">m2m_wifi_get_firmware_version</a> (<a class="el" href="structtstr_m2m_rev.html">tstrM2mRev</a> *pstrRev)</td></tr>
<tr class="memdesc:gac0ca8bc0a8c78acaa115ddb677f55401"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous API to obtain the firmware version currently running on the WINC.  <a href="group__m2m__wifi.html#gac0ca8bc0a8c78acaa115ddb677f55401">More...</a><br /></td></tr>
<tr class="separator:gac0ca8bc0a8c78acaa115ddb677f55401"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga26c229a7bbf756c2192c64fac8104af4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___w_l_a_n_callbacks.html#ga736f9be563605a41689b47de03de14d0">tpfAppWifiCb</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga26c229a7bbf756c2192c64fac8104af4">pfAppWifiCb</a></td></tr>
<tr class="separator:ga26c229a7bbf756c2192c64fac8104af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04b95b307175b8ca1033a1597aa339b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___w_l_a_n_callbacks.html#ga5884506e89485befb4d0072be7f9be4f">tpfAppEthCb</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga04b95b307175b8ca1033a1597aa339b3">pfAppEthCb</a></td></tr>
<tr class="separator:ga04b95b307175b8ca1033a1597aa339b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6eab17798504ca5514ec11a639d91798"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga6eab17798504ca5514ec11a639d91798">au8ethRcvBuf</a></td></tr>
<tr class="separator:ga6eab17798504ca5514ec11a639d91798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a2bca251ff02e16282d25b3198b02bc"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga6a2bca251ff02e16282d25b3198b02bc">u16ethRcvBufSize</a></td></tr>
<tr class="separator:ga6a2bca251ff02e16282d25b3198b02bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5df4e7912619fb37a4403ba45a54ea03"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga5df4e7912619fb37a4403ba45a54ea03">u8EthernetEnable</a></td></tr>
<tr class="separator:ga5df4e7912619fb37a4403ba45a54ea03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga232485ba9f2825687f04342ed646d1c4"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga232485ba9f2825687f04342ed646d1c4">u16DataSize</a></td></tr>
<tr class="separator:ga232485ba9f2825687f04342ed646d1c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2b20fa12030589032bd8fe46b9e84c1"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#gae2b20fa12030589032bd8fe46b9e84c1">u16RemainingDataSize</a></td></tr>
<tr class="separator:gae2b20fa12030589032bd8fe46b9e84c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26c229a7bbf756c2192c64fac8104af4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___w_l_a_n_callbacks.html#ga736f9be563605a41689b47de03de14d0">tpfAppWifiCb</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga26c229a7bbf756c2192c64fac8104af4">pfAppWifiCb</a></td></tr>
<tr class="separator:ga26c229a7bbf756c2192c64fac8104af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59cd226561744cd8589eb7d3b91f2bb9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtstr_eth_init_param.html">tstrEthInitParam</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga59cd226561744cd8589eb7d3b91f2bb9">strEthInitParam</a></td></tr>
<tr class="separator:ga59cd226561744cd8589eb7d3b91f2bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga287a132fe4ce1c882d1abcdad44a9a73"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga287a132fe4ce1c882d1abcdad44a9a73">pu8Bssid</a></td></tr>
<tr class="separator:ga287a132fe4ce1c882d1abcdad44a9a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae754bc1fbe103335162107d2555eea22"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#gae754bc1fbe103335162107d2555eea22">pu8Ssid</a></td></tr>
<tr class="separator:gae754bc1fbe103335162107d2555eea22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabed21391be96e9cccf3fcf3d72904c95"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#gabed21391be96e9cccf3fcf3d72904c95">u8SsidLen</a></td></tr>
<tr class="separator:gabed21391be96e9cccf3fcf3d72904c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga400ea613d8260b3e87180cf0e2ab918c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___w_l_a_n_enums.html#ga2a91dd671e2672dba1a7ed45230f3a99">tenuM2mScanCh</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga400ea613d8260b3e87180cf0e2ab918c">enuChannel</a></td></tr>
<tr class="separator:ga400ea613d8260b3e87180cf0e2ab918c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga832373e5239b512421233481ed583b55"><td class="memItemLeft" align="right" valign="top"><a id="ga832373e5239b512421233481ed583b55"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>u8KeyIndx</b></td></tr>
<tr class="separator:ga832373e5239b512421233481ed583b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebc6c619e657cb1f135b454a36c1bd00"><td class="memItemLeft" align="right" valign="top"><a id="gaebc6c619e657cb1f135b454a36c1bd00"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>u8KeySz</b></td></tr>
<tr class="separator:gaebc6c619e657cb1f135b454a36c1bd00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5374e91ce352528bd7df67091c6a3d77"><td class="memItemLeft" align="right" valign="top"><a id="ga5374e91ce352528bd7df67091c6a3d77"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>au8WepKey</b> [<a class="el" href="group___w_l_a_n_defines.html#ga087f8be759b11ec0fe841d21e60367f5">WEP_104_KEY_STRING_SIZE</a>+1]</td></tr>
<tr class="separator:ga5374e91ce352528bd7df67091c6a3d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5a8cce92864d5c9acd5c53b25370d90"><td class="memItemLeft" align="right" valign="top"><a id="gaa5a8cce92864d5c9acd5c53b25370d90"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>__PAD24__</b> [3]</td></tr>
<tr class="separator:gaa5a8cce92864d5c9acd5c53b25370d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2bfbab9a2c69088369c22db978fdc35"><td class="memItemLeft" align="right" valign="top"><a id="gab2bfbab9a2c69088369c22db978fdc35"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>au8UserName</b> [21]</td></tr>
<tr class="separator:gab2bfbab9a2c69088369c22db978fdc35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7df4a55ccd4ce9f19bfce72a762d1bf4"><td class="memItemLeft" align="right" valign="top"><a id="ga7df4a55ccd4ce9f19bfce72a762d1bf4"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>au8Passwd</b> [41]</td></tr>
<tr class="separator:ga7df4a55ccd4ce9f19bfce72a762d1bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c209e9fd0066f841e026d6ad36cf156"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga6c209e9fd0066f841e026d6ad36cf156">pu8Psk</a></td></tr>
<tr class="separator:ga6c209e9fd0066f841e026d6ad36cf156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga579fb13e7238b99432d79f833a7dfc66"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga579fb13e7238b99432d79f833a7dfc66">pu8Passphrase</a></td></tr>
<tr class="separator:ga579fb13e7238b99432d79f833a7dfc66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92ec1391f4ae4ef43f7a87dd9bcdcbee"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga92ec1391f4ae4ef43f7a87dd9bcdcbee">u8PassphraseLen</a></td></tr>
<tr class="separator:ga92ec1391f4ae4ef43f7a87dd9bcdcbee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga450c7d4c29c5ddfb9833ec0850bf0910"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga450c7d4c29c5ddfb9833ec0850bf0910">pu8WepKey</a></td></tr>
<tr class="separator:ga450c7d4c29c5ddfb9833ec0850bf0910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebc6c619e657cb1f135b454a36c1bd00"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#gaebc6c619e657cb1f135b454a36c1bd00">u8KeySz</a></td></tr>
<tr class="separator:gaebc6c619e657cb1f135b454a36c1bd00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga832373e5239b512421233481ed583b55"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga832373e5239b512421233481ed583b55">u8KeyIndx</a></td></tr>
<tr class="separator:ga832373e5239b512421233481ed583b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fe5c84bf6a89322f1255f9a97456a86"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga8fe5c84bf6a89322f1255f9a97456a86">pu8Domain</a></td></tr>
<tr class="separator:ga8fe5c84bf6a89322f1255f9a97456a86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bbedda404b3d97df036782d489c0a6d"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga7bbedda404b3d97df036782d489c0a6d">pu8UserName</a></td></tr>
<tr class="separator:ga7bbedda404b3d97df036782d489c0a6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae371d5cc2b4521e753d1cf3656005a83"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#gae371d5cc2b4521e753d1cf3656005a83">pu8Password</a></td></tr>
<tr class="separator:gae371d5cc2b4521e753d1cf3656005a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga631a045f636cbf5a32f7fdf4e2d6834d"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga631a045f636cbf5a32f7fdf4e2d6834d">u16DomainLen</a></td></tr>
<tr class="separator:ga631a045f636cbf5a32f7fdf4e2d6834d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84a9ef217bc07bfd09d20b401547b3cf"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga84a9ef217bc07bfd09d20b401547b3cf">u16UserNameLen</a></td></tr>
<tr class="separator:ga84a9ef217bc07bfd09d20b401547b3cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8dc5df15e08785d98f423ba7bcd28981"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga8dc5df15e08785d98f423ba7bcd28981">u16PasswordLen</a></td></tr>
<tr class="separator:ga8dc5df15e08785d98f423ba7bcd28981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac969c4653cf2a296c15b3316c441e99b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#gac969c4653cf2a296c15b3316c441e99b">bUnencryptedUserName</a></td></tr>
<tr class="separator:gac969c4653cf2a296c15b3316c441e99b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59bf2ba72a950da5b20edc7c0fe030d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga59bf2ba72a950da5b20edc7c0fe030d3">bPrependDomain</a></td></tr>
<tr class="separator:ga59bf2ba72a950da5b20edc7c0fe030d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fe5c84bf6a89322f1255f9a97456a86"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga8fe5c84bf6a89322f1255f9a97456a86">pu8Domain</a></td></tr>
<tr class="separator:ga8fe5c84bf6a89322f1255f9a97456a86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bbedda404b3d97df036782d489c0a6d"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga7bbedda404b3d97df036782d489c0a6d">pu8UserName</a></td></tr>
<tr class="separator:ga7bbedda404b3d97df036782d489c0a6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2dc2ceebbae6853d436ac193d2ed8210"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga2dc2ceebbae6853d436ac193d2ed8210">pu8PrivateKey_Mod</a></td></tr>
<tr class="separator:ga2dc2ceebbae6853d436ac193d2ed8210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3520c9f97099d36c89048c23b81b8ffc"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga3520c9f97099d36c89048c23b81b8ffc">pu8PrivateKey_Exp</a></td></tr>
<tr class="separator:ga3520c9f97099d36c89048c23b81b8ffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e7c800089f87906813e765eed92fdfb"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga5e7c800089f87906813e765eed92fdfb">pu8Certificate</a></td></tr>
<tr class="separator:ga5e7c800089f87906813e765eed92fdfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga631a045f636cbf5a32f7fdf4e2d6834d"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga631a045f636cbf5a32f7fdf4e2d6834d">u16DomainLen</a></td></tr>
<tr class="separator:ga631a045f636cbf5a32f7fdf4e2d6834d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84a9ef217bc07bfd09d20b401547b3cf"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga84a9ef217bc07bfd09d20b401547b3cf">u16UserNameLen</a></td></tr>
<tr class="separator:ga84a9ef217bc07bfd09d20b401547b3cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga700c7ef365b380b9478aea26af1a04ff"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga700c7ef365b380b9478aea26af1a04ff">u16PrivateKeyLen</a></td></tr>
<tr class="separator:ga700c7ef365b380b9478aea26af1a04ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3627f8e04acc0b6cdbfbddcf21e6d1bc"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga3627f8e04acc0b6cdbfbddcf21e6d1bc">u16CertificateLen</a></td></tr>
<tr class="separator:ga3627f8e04acc0b6cdbfbddcf21e6d1bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac969c4653cf2a296c15b3316c441e99b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#gac969c4653cf2a296c15b3316c441e99b">bUnencryptedUserName</a></td></tr>
<tr class="separator:gac969c4653cf2a296c15b3316c441e99b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59bf2ba72a950da5b20edc7c0fe030d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m2m__wifi.html#ga59bf2ba72a950da5b20edc7c0fe030d3">bPrependDomain</a></td></tr>
<tr class="separator:ga59bf2ba72a950da5b20edc7c0fe030d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga9055e2da0c384ac1fd8b790edce66141"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9055e2da0c384ac1fd8b790edce66141">&#9670;&nbsp;</a></span>m2m_wifi_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void m2m_wifi_cb </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>u8OpCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>u16DataSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>u32Addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal WiFi callback function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">u8OpCode</td><td>HIF Opcode type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">u16DataSize</td><td>HIF data length. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">u32Addr</td><td>HIF address. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6ac5925878de8a3b57c8287c2b10663d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ac5925878de8a3b57c8287c2b10663d">&#9670;&nbsp;</a></span>m2m_wifi_conf_auto_rate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_wifi_conf_auto_rate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtstr_conf_auto_rate.html">tstrConfAutoRate</a> *&#160;</td>
          <td class="paramname"><em>pstrConfAutoRate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures WLAN automatic TX rate adaptation algorithm. </p>
<p>Allow the host MCU app to configure auto TX rate selection algorithm. The application can use this API to tweak the algorithm performance. Moreover, it allows the application to force a specific WLAN PHY rate for transmitted data packets to favor range vs. throughput needs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pstrConfAutoRate</td><td>The Auto rate configuration parameters as listed in <a class="el" href="structtstr_conf_auto_rate.html" title="Auto TX rate selection parameters passed to m2m_wifi_conf_auto_rate.">tstrConfAutoRate</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function SHALL return M2M_SUCCESS for success and a negative value otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtstr_conf_auto_rate.html" title="Auto TX rate selection parameters passed to m2m_wifi_conf_auto_rate.">tstrConfAutoRate</a> </dd></dl>

</div>
</div>
<a id="ga29af80f4f2d3bd510cb1f814ed8590d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29af80f4f2d3bd510cb1f814ed8590d3">&#9670;&nbsp;</a></span>m2m_wifi_configure_sntp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_wifi_configure_sntp </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pu8NTPServerName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>u8NTPServerNameLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___w_l_a_n_enums.html#ga8eef709e17dc0454c9fd556f302766e2">tenuSNTPUseDHCP</a>&#160;</td>
          <td class="paramname"><em>enuUseDHCP</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures what NTP server the SNTP client should use. </p>
<p>Configures what NTP server the SNTP client should use. Only 1 server name can be provided, if the configured server name begins with an asterisk then it will be treated as a server pool. The SNTP client can also use the NTP server provided by the DHCP server through option 42. By default the NTP server provided by DHCP will be tried first, then the built-in default NTP server (time.nist.gov) will be used. Configuring a server name will overwrite the built-in default server until next reboot.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pu8NTPServerName</td><td>Buffer holding the NTP server name. If the first character is an asterisk (*) then it will be treated as a server pool, where the asterisk will be replaced with an incrementing value from 0 to 3 each time a server fails (example: *.pool.ntp.org).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">u8NTPServerNameLength</td><td>Length of the NTP server name. Should not exceed the maximum NTP server name length of <a class="el" href="group___w_l_a_n_defines.html#ga8a697d06854e3e602bd2a2464149fd08">M2M_NTP_MAX_SERVER_NAME_LENGTH</a>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enuUseDHCP</td><td>Should the NTP server provided by the DHCP server be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns M2M_SUCCESS for success and a negative value otherwise. </dd></dl>

</div>
</div>
<a id="ga39167bb6c3a20a24f46b387e7096d501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39167bb6c3a20a24f46b387e7096d501">&#9670;&nbsp;</a></span>m2m_wifi_connect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_wifi_connect </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pcSsid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>u8SsidLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>u8SecType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pvAuthInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>u16Ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DEPRECATED in v19.6.1 - Kept only for legacy purposes.<br  />
 Legacy asynchronous API to request connection to a specified access point. </p>
<p>Prior to a successful connection, the application developers must know the SSID, the security type, and the authentication parameters of the target access point; knowledge of the channel number is optional.</p>
<p>The connection status will be indicated to the application via a <a class="el" href="group___w_l_a_n_enums.html#gga064de09dec1d5e88ed8d075fa40f57deabb42b3025c56c51d915a1fa4abd2dbd0">M2M_WIFI_RESP_CON_STATE_CHANGED</a> event. The status will be one of those defined in <a class="el" href="group___w_l_a_n_enums.html#ga460c311f58f4c40c3d20eec9e99db586">tenuM2mConnState</a> withe <a class="el" href="group___w_l_a_n_enums.html#gga460c311f58f4c40c3d20eec9e99db586a9196649c19ee10e2168e08a5b4785938">M2M_WIFI_CONNECTED</a> indicating a successful connection.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pcSsid</td><td>A buffer holding the SSID corresponding to the requested AP. SSID must not contain '\0'.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">u8SsidLen</td><td>Length of the given SSID (not including any NULL termination). A length greater than or equal to <a class="el" href="group___w_l_a_n_defines.html#gab2bd95c18ede2fbc07b44c5660cc0097">M2M_MAX_SSID_LEN</a> will result in a negative error M2M_ERR_FAIL.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">u8SecType</td><td>Wi-Fi security type security for the network. It can be one of the following types: -<a class="el" href="group___w_l_a_n_enums.html#ggaa232a09c953ec8200c13774f94107b05a81b513753be791c13b73d0b2d3639b69">M2M_WIFI_SEC_OPEN</a> -<a class="el" href="group___w_l_a_n_enums.html#ggaa232a09c953ec8200c13774f94107b05a0bb64825e9635113bbab91934b214780">M2M_WIFI_SEC_WEP</a> -<a class="el" href="group___w_l_a_n_enums.html#ggaa232a09c953ec8200c13774f94107b05a951d0504fc8e173e60df8ee871f16697">M2M_WIFI_SEC_WPA_PSK</a> -<a class="el" href="group___w_l_a_n_enums.html#ggaa232a09c953ec8200c13774f94107b05a0fcff26361d2f1e5378abf20e51913b5">M2M_WIFI_SEC_802_1X</a> A value outside these possible values will result in a negative return error M2M_ERR_FAIL.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pvAuthInfo</td><td>Authentication parameters required for completing the connection. Its type is based on the security type. If the authentication parameters are NULL or are greater than the maximum length of the authentication parameters length as defined by <a class="el" href="group___w_l_a_n_defines.html#ga790a7e0471ff8a179238863dc2021f6d">M2M_MAX_PSK_LEN</a> a negative error will return M2M_ERR_FAIL indicating connection failure.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">u16Ch</td><td>Wi-Fi channel number as defined in <a class="el" href="group___w_l_a_n_enums.html#ga2a91dd671e2672dba1a7ed45230f3a99">tenuM2mScanCh</a> enumeration. Specifying a channel number greater than <a class="el" href="group___w_l_a_n_enums.html#gga2a91dd671e2672dba1a7ed45230f3a99a6421cfaf77ed29e91106d39e69e4a970">M2M_WIFI_CH_14</a> returns a negative error M2M_ERR_FAIL, unless the value is M2M_WIFI_CH_ALL, since this indicates that the firmware should scan all channels to find the SSID specified in parameter pcSsid.</td></tr>
  </table>
  </dd>
</dl>
<p>Failure to find the connection match will return a negative error <a class="el" href="group___w_l_a_n_enums.html#gga6a91fa29dec13711074431422c220ae6ad21f428be96f28b6022b267fa7a12476">M2M_DEFAULT_CONN_SCAN_MISMATCH</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Prior to a successful connection request, the Wi-Fi driver must have been successfully initialized through the call of the <a class="el" href="group__m2m__wifi.html#ga66f5bf5f84f898bdd4453f2717a3deb5">m2m_wifi_init</a> function.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If there is a '\0' character within the first u8SsidLen characters, then this function will assume that the input u8SsidLen was incorrect, set length to strlen(pcSsid) and continue.<br  />
 This function has been deprecated since v19.6.1 and will no longer be supported afterwards. The following should be used instead: <a class="el" href="group__m2m__wifi.html#ga8d684fd730f5175c281f3ac7a2b4eafa">m2m_wifi_connect_open</a> <a class="el" href="group__m2m__wifi.html#gaf276c05ac4568cabafe9e0cf3861b154">m2m_wifi_connect_wep</a> <a class="el" href="group__m2m__wifi.html#gaa131b2fb19e32077923852539b807a84">m2m_wifi_connect_psk</a> <a class="el" href="group__m2m__wifi.html#ga8bdfa38e51644e958d866d5495fe8a98">m2m_wifi_connect_1x_mschap2</a> <a class="el" href="group__m2m__wifi.html#ga5b22373211fefea8a547f28f27f4a402">m2m_wifi_connect_1x_tls</a></dd></dl>
<p>Additionally:</p><ul>
<li>This function must be called in station mode only.</li>
<li>Successful completion of this function does not guarantee success of the WIFI connection, and a negative return value indicates only locally-detected errors.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>The function returns M2M_SUCCESS if the command has been successfully queued to the WINC and a negative value otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtstr1x_auth_credentials.html">tstr1xAuthCredentials</a> <a class="el" href="structtstr_m2m_wifi_wep_params.html">tstrM2mWifiWepParams</a> </dd></dl>

</div>
</div>
<a id="ga8bdfa38e51644e958d866d5495fe8a98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8bdfa38e51644e958d866d5495fe8a98">&#9670;&nbsp;</a></span>m2m_wifi_connect_1x_mschap2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_wifi_connect_1x_mschap2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___w_l_a_n_enums.html#ga5669e8f0b3b645d5ece2519a33cf8c2c">tenuCredStoreOption</a>&#160;</td>
          <td class="paramname"><em>enuCredStoreOption</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtstr_network_id.html">tstrNetworkId</a> *&#160;</td>
          <td class="paramname"><em>pstrNetworkId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtstr_auth1x_mschap2.html">tstrAuth1xMschap2</a> *&#160;</td>
          <td class="paramname"><em>pstrAuth1xMschap2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronous API to connect to an access point using WPA(2) Enterprise authentication with MS-CHAP-V2 credentials. </p>
<p>Asynchronous Wi-Fi connection function. An application calling this function will cause the firmware to attempt to connect to an access point matching the details in pstrNetworkId, with the Enterprise MS-CHAP-V2 credentials provided in pstrAuth1xMschap2. On successful connection, the connection details may be saved in WINC's flash, according to the option selected in enuCredStoreOption. Once connection has been attempted (whether successful or otherwise), a response event <a class="el" href="group___w_l_a_n_enums.html#gga064de09dec1d5e88ed8d075fa40f57deabb42b3025c56c51d915a1fa4abd2dbd0">M2M_WIFI_RESP_CON_STATE_CHANGED</a> will be sent to the callback function tpfAppWifiCb provided during initialization <a class="el" href="group__m2m__wifi.html#ga66f5bf5f84f898bdd4453f2717a3deb5">m2m_wifi_init</a>.</p>
<p>Possible results indicated by the response event are:</p><ul>
<li><a class="el" href="group___w_l_a_n_enums.html#gga460c311f58f4c40c3d20eec9e99db586a0c24dd073c9dde02e789858e161f7106">M2M_WIFI_DISCONNECTED</a> if the connection attempt failed.</li>
<li><a class="el" href="group___w_l_a_n_enums.html#gga460c311f58f4c40c3d20eec9e99db586a9196649c19ee10e2168e08a5b4785938">M2M_WIFI_CONNECTED</a> if the connection attempt succeeded.</li>
</ul>
<dl class="section pre"><dt>Precondition</dt><dd>Prior to attempting connection, the WINC driver must have been initialized by calling the <a class="el" href="group__m2m__wifi.html#ga66f5bf5f84f898bdd4453f2717a3deb5">m2m_wifi_init</a> function.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is handled in station mode only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">enuCredStoreOption</td><td>Option to specify whether connection details (i.e. the contents of pstrNetworkId and pstrAuth1xMschap2) are stored in WINC's flash and, if so, whether they are encrypted before storing.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pstrNetworkId</td><td>Structure specifying SSID/BSSID and Wi-Fi channel.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pstrAuth1xMschap2</td><td>Structure specifying the MS-CHAP-V2 credentials.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns M2M_SUCCESS if the connect request has been successfully passed to the firmware and a negative value otherwise. </dd></dl>

</div>
</div>
<a id="ga5b22373211fefea8a547f28f27f4a402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b22373211fefea8a547f28f27f4a402">&#9670;&nbsp;</a></span>m2m_wifi_connect_1x_tls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_wifi_connect_1x_tls </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___w_l_a_n_enums.html#ga5669e8f0b3b645d5ece2519a33cf8c2c">tenuCredStoreOption</a>&#160;</td>
          <td class="paramname"><em>enuCredStoreOption</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtstr_network_id.html">tstrNetworkId</a> *&#160;</td>
          <td class="paramname"><em>pstrNetworkId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtstr_auth1x_tls.html">tstrAuth1xTls</a> *&#160;</td>
          <td class="paramname"><em>pstrAuth1xTls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronous API to connect to an access point using WPA(2) Enterprise authentication with MS-CHAP-V2 credentials. </p>
<p>Asynchronous Wi-Fi connection function. An application calling this function will cause the firmware to attempt to connect to an access point matching the details in pstrNetworkId, with the Enterprise TLS credentials provided in pstrAuth1xTls. On successful connection, the connection details may be saved in WINC's flash, according to the option selected in enuCredStoreOption. Once connection has been attempted (whether successful or otherwise), a response event <a class="el" href="group___w_l_a_n_enums.html#gga064de09dec1d5e88ed8d075fa40f57deabb42b3025c56c51d915a1fa4abd2dbd0">M2M_WIFI_RESP_CON_STATE_CHANGED</a> will be sent to the callback function <a class="el" href="group___w_l_a_n_callbacks.html#ga736f9be563605a41689b47de03de14d0">tpfAppWifiCb</a> provided during initialization <a class="el" href="group__m2m__wifi.html#ga66f5bf5f84f898bdd4453f2717a3deb5">m2m_wifi_init</a>.</p>
<p>Possible results indicated by the response event are:</p><ul>
<li><a class="el" href="group___w_l_a_n_enums.html#gga460c311f58f4c40c3d20eec9e99db586a0c24dd073c9dde02e789858e161f7106">M2M_WIFI_DISCONNECTED</a> if the connection attempt failed.</li>
<li><a class="el" href="group___w_l_a_n_enums.html#gga460c311f58f4c40c3d20eec9e99db586a9196649c19ee10e2168e08a5b4785938">M2M_WIFI_CONNECTED</a> if the connection attempt succeeded.</li>
</ul>
<dl class="section pre"><dt>Precondition</dt><dd>Prior to attempting connection, the WINC driver must have been initialized by calling the <a class="el" href="group__m2m__wifi.html#ga66f5bf5f84f898bdd4453f2717a3deb5">m2m_wifi_init</a> function.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is handled in station mode only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">enuCredStoreOption</td><td>Option to specify whether connection details (i.e. the contents of pstrNetworkId and pstrAuth1xTls) are stored in WINC's flash and, if so, whether they are encrypted before storing.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pstrNetworkId</td><td>Structure specifying SSID/BSSID and Wi-Fi channel.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pstrAuth1xTls</td><td>Structure specifying the EAP-TLS credentials.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns M2M_SUCCESS if the connect request has been successfully passed to the firmware and a negative value otherwise. </dd></dl>

</div>
</div>
<a id="ga8d684fd730f5175c281f3ac7a2b4eafa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d684fd730f5175c281f3ac7a2b4eafa">&#9670;&nbsp;</a></span>m2m_wifi_connect_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_wifi_connect_open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___w_l_a_n_enums.html#ga5669e8f0b3b645d5ece2519a33cf8c2c">tenuCredStoreOption</a>&#160;</td>
          <td class="paramname"><em>enuCredStoreOption</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtstr_network_id.html">tstrNetworkId</a> *&#160;</td>
          <td class="paramname"><em>pstrNetworkId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronous API to connect to an access point using open authentication. </p>
<p>Asynchronous Wi-Fi connection function. An application calling this function will cause the firmware to attempt to connect to an access point matching the details in pstrNetworkId, with open authentication. On successful connection, the connection details may be saved in WINC's flash, according to the option selected in enuCredStoreOption. Once connection has been attempted (whether successful or otherwise), a response event <a class="el" href="group___w_l_a_n_enums.html#gga064de09dec1d5e88ed8d075fa40f57deabb42b3025c56c51d915a1fa4abd2dbd0">M2M_WIFI_RESP_CON_STATE_CHANGED</a> will be sent to the callback function <a class="el" href="group___w_l_a_n_callbacks.html#ga736f9be563605a41689b47de03de14d0">tpfAppWifiCb</a> provided during initialization <a class="el" href="group__m2m__wifi.html#ga66f5bf5f84f898bdd4453f2717a3deb5">m2m_wifi_init</a>.</p>
<p>Possible results indicated by the response event are:</p><ul>
<li><a class="el" href="group___w_l_a_n_enums.html#gga460c311f58f4c40c3d20eec9e99db586a0c24dd073c9dde02e789858e161f7106">M2M_WIFI_DISCONNECTED</a> if the connection attempt failed.</li>
<li><a class="el" href="group___w_l_a_n_enums.html#gga460c311f58f4c40c3d20eec9e99db586a9196649c19ee10e2168e08a5b4785938">M2M_WIFI_CONNECTED</a> if the connection attempt succeeded.</li>
</ul>
<dl class="section pre"><dt>Precondition</dt><dd>Prior to attempting connection, the WINC driver must have been initialized by calling the <a class="el" href="group__m2m__wifi.html#ga66f5bf5f84f898bdd4453f2717a3deb5">m2m_wifi_init</a> function.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is handled in station mode only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">enuCredStoreOption</td><td>Option to specify whether connection details (i.e. the contents of pstrNetworkId) are stored in WINC's flash and, if so, whether they are encrypted before storing.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pstrNetworkId</td><td>Structure specifying SSID/BSSID and Wi-Fi channel.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns M2M_SUCCESS if the connect request has been successfully passed to the firmware and a negative value otherwise. </dd></dl>

</div>
</div>
<a id="gaa131b2fb19e32077923852539b807a84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa131b2fb19e32077923852539b807a84">&#9670;&nbsp;</a></span>m2m_wifi_connect_psk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_wifi_connect_psk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___w_l_a_n_enums.html#ga5669e8f0b3b645d5ece2519a33cf8c2c">tenuCredStoreOption</a>&#160;</td>
          <td class="paramname"><em>enuCredStoreOption</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtstr_network_id.html">tstrNetworkId</a> *&#160;</td>
          <td class="paramname"><em>pstrNetworkId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtstr_auth_psk.html">tstrAuthPsk</a> *&#160;</td>
          <td class="paramname"><em>pstrAuthPsk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronous API to connect to an access point using WPA(2) PSK authentication. </p>
<p>Asynchronous Wi-Fi connection function. An application calling this function will cause the firmware to attempt to connect to an access point matching the details in pstrNetworkId, with the PSK passphrase provided in pstrAuthPsk. On successful connection, the connection details may be saved in WINC's flash, according to the option selected in enuCredStoreOption. Once connection has been attempted (whether successful or otherwise), a response event <a class="el" href="group___w_l_a_n_enums.html#gga064de09dec1d5e88ed8d075fa40f57deabb42b3025c56c51d915a1fa4abd2dbd0">M2M_WIFI_RESP_CON_STATE_CHANGED</a> will be sent to the callback function <a class="el" href="group___w_l_a_n_callbacks.html#ga736f9be563605a41689b47de03de14d0">tpfAppWifiCb</a> provided during initialization <a class="el" href="group__m2m__wifi.html#ga66f5bf5f84f898bdd4453f2717a3deb5">m2m_wifi_init</a>.</p>
<p>Possible results indicated by the response event are:</p><ul>
<li><a class="el" href="group___w_l_a_n_enums.html#gga460c311f58f4c40c3d20eec9e99db586a0c24dd073c9dde02e789858e161f7106">M2M_WIFI_DISCONNECTED</a> if the connection attempt failed.</li>
<li><a class="el" href="group___w_l_a_n_enums.html#gga460c311f58f4c40c3d20eec9e99db586a9196649c19ee10e2168e08a5b4785938">M2M_WIFI_CONNECTED</a> if the connection attempt succeeded.</li>
</ul>
<dl class="section pre"><dt>Precondition</dt><dd>Prior to attempting connection, the WINC driver must have been initialized by calling the <a class="el" href="group__m2m__wifi.html#ga66f5bf5f84f898bdd4453f2717a3deb5">m2m_wifi_init</a> function.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is handled in station mode only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">enuCredStoreOption</td><td>Option to specify whether connection details (i.e. the contents of pstrNetworkId and pstrAuthPsk) are stored in WINC's flash and, if so, whether they are encrypted before storing.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pstrNetworkId</td><td>Structure specifying SSID/BSSID and Wi-Fi channel.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pstrAuthPsk</td><td>Structure specifying the Passphrase/PSK.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns M2M_SUCCESS if the connect request has been successfully passed to the firmware and a negative value otherwise. </dd></dl>

</div>
</div>
<a id="ga89df08f98aca47e8fb4c584d74d1bd3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89df08f98aca47e8fb4c584d74d1bd3f">&#9670;&nbsp;</a></span>m2m_wifi_connect_sc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_wifi_connect_sc </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pcSsid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>u8SsidLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>u8SecType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pvAuthInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>u16Ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>u8NoSaveCred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DEPRECATED in v19.6.1 - Kept only for legacy purposes.<br  />
 Legacy asynchronous API to request connection to a specific AP with the option to save credentials in Flash. </p>
<p>Prior to a successful connection, the application developers must know the SSID, the security type, and the authentication parameters of the target access point; knowledge of the channel number is optional.</p>
<p>The connection status will be indicated to the application via a <a class="el" href="group___w_l_a_n_enums.html#gga064de09dec1d5e88ed8d075fa40f57deabb42b3025c56c51d915a1fa4abd2dbd0">M2M_WIFI_RESP_CON_STATE_CHANGED</a> event. The status will be one of those defined in <a class="el" href="group___w_l_a_n_enums.html#ga460c311f58f4c40c3d20eec9e99db586">tenuM2mConnState</a> withe <a class="el" href="group___w_l_a_n_enums.html#gga460c311f58f4c40c3d20eec9e99db586a9196649c19ee10e2168e08a5b4785938">M2M_WIFI_CONNECTED</a> indicating a successful connection.</p>
<p>The only difference between this function and <a class="el" href="group__m2m__wifi.html#ga39167bb6c3a20a24f46b387e7096d501">m2m_wifi_connect</a>, is the option to save the acess point info ( SSID, password...etc) into flash.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pcSsid</td><td>A buffer holding the SSID corresponding to the requested AP. SSID must not contain '\0'.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">u8SsidLen</td><td>Length of the given SSID (not including any NULL termination). A length greater than or equal to <a class="el" href="group___w_l_a_n_defines.html#gab2bd95c18ede2fbc07b44c5660cc0097">M2M_MAX_SSID_LEN</a> will result in a negative error M2M_ERR_FAIL.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">u8SecType</td><td>Wi-Fi security type security for the network (see <a class="el" href="group___w_l_a_n_enums.html#gaa232a09c953ec8200c13774f94107b05">tenuM2mSecType</a>). It can be one of the following types: -<a class="el" href="group___w_l_a_n_enums.html#ggaa232a09c953ec8200c13774f94107b05a81b513753be791c13b73d0b2d3639b69">M2M_WIFI_SEC_OPEN</a> -<a class="el" href="group___w_l_a_n_enums.html#ggaa232a09c953ec8200c13774f94107b05a0bb64825e9635113bbab91934b214780">M2M_WIFI_SEC_WEP</a> -<a class="el" href="group___w_l_a_n_enums.html#ggaa232a09c953ec8200c13774f94107b05a951d0504fc8e173e60df8ee871f16697">M2M_WIFI_SEC_WPA_PSK</a> -<a class="el" href="group___w_l_a_n_enums.html#ggaa232a09c953ec8200c13774f94107b05a0fcff26361d2f1e5378abf20e51913b5">M2M_WIFI_SEC_802_1X</a> A value outside these possible values will result in a negative return error M2M_ERR_FAIL.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pvAuthInfo</td><td>Authentication parameters required for completing the connection. Its type is based on the security type. If the authentication parameters are NULL or are greater than the maximum length of the authentication parameters length as defined by <a class="el" href="group___w_l_a_n_defines.html#ga790a7e0471ff8a179238863dc2021f6d">M2M_MAX_PSK_LEN</a> a negative error will return M2M_ERR_FAIL indicating connection failure.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">u16Ch</td><td>Wi-Fi channel number as defined in <a class="el" href="group___w_l_a_n_enums.html#ga2a91dd671e2672dba1a7ed45230f3a99">tenuM2mScanCh</a> enumeration. Specification of a channel number greater than <a class="el" href="group___w_l_a_n_enums.html#gga2a91dd671e2672dba1a7ed45230f3a99a6421cfaf77ed29e91106d39e69e4a970">M2M_WIFI_CH_14</a> returns a negative error M2M_ERR_FAIL unless the value is M2M_WIFI_CH_ALL. A channel number of M2M_WIFI_CH_ALL indicates that the firmware should scan all channels to find the SSID specified in parameter pcSsid.</td></tr>
  </table>
  </dd>
</dl>
<p>Failure to find the connection match will return a negative error <a class="el" href="group___w_l_a_n_enums.html#gga6a91fa29dec13711074431422c220ae6ad21f428be96f28b6022b267fa7a12476">M2M_DEFAULT_CONN_SCAN_MISMATCH</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">u8NoSaveCred</td><td>Option to store the access point SSID and password into the WINC flash memory or not.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Prior to a successful connection request, the Wi-Fi driver must have been successfully initialized through the call of the <a class="el" href="group__m2m__wifi.html#ga66f5bf5f84f898bdd4453f2717a3deb5">m2m_wifi_init</a> function.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If there is a '\0' character within the first u8SsidLen characters, then this function will assume that the input u8SsidLen was incorrect, set length to strlen(pcSsid) and continue.<br  />
 This function has been deprecated since v19.6.1 and will no longer be supported afterwards. The following should be used instead: <a class="el" href="group__m2m__wifi.html#ga8d684fd730f5175c281f3ac7a2b4eafa">m2m_wifi_connect_open</a> <a class="el" href="group__m2m__wifi.html#gaf276c05ac4568cabafe9e0cf3861b154">m2m_wifi_connect_wep</a> <a class="el" href="group__m2m__wifi.html#gaa131b2fb19e32077923852539b807a84">m2m_wifi_connect_psk</a> <a class="el" href="group__m2m__wifi.html#ga8bdfa38e51644e958d866d5495fe8a98">m2m_wifi_connect_1x_mschap2</a> <a class="el" href="group__m2m__wifi.html#ga5b22373211fefea8a547f28f27f4a402">m2m_wifi_connect_1x_tls</a></dd></dl>
<p>Additionally:</p><ul>
<li>This function must be called in station mode only.</li>
<li>Successful completion of this function does not guarantee success of the WIFI connection, and a negative return value indicates only locally-detected errors.</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___w_l_a_n_enums.html#gaa232a09c953ec8200c13774f94107b05" title="This enum contains all the supported Wi-Fi security types.">tenuM2mSecType</a> <a class="el" href="structtstr1x_auth_credentials.html">tstr1xAuthCredentials</a> <a class="el" href="structtstr_m2m_wifi_wep_params.html">tstrM2mWifiWepParams</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns M2M_SUCCESS if the command has been successfully queued to the WINC and a negative value otherwise. </dd></dl>

</div>
</div>
<a id="gaf276c05ac4568cabafe9e0cf3861b154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf276c05ac4568cabafe9e0cf3861b154">&#9670;&nbsp;</a></span>m2m_wifi_connect_wep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_wifi_connect_wep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___w_l_a_n_enums.html#ga5669e8f0b3b645d5ece2519a33cf8c2c">tenuCredStoreOption</a>&#160;</td>
          <td class="paramname"><em>enuCredStoreOption</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtstr_network_id.html">tstrNetworkId</a> *&#160;</td>
          <td class="paramname"><em>pstrNetworkId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtstr_auth_wep.html">tstrAuthWep</a> *&#160;</td>
          <td class="paramname"><em>pstrAuthWep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronous API to connect to an access point using WEP authentication. </p>
<p>Asynchronous Wi-Fi connection function. An application calling this function will cause the firmware to attempt to connect to an access point matching the details in pstrNetworkId, with the WEP key provided in pstrAuthWep. On successful connection, the connection details may be saved in WINC's flash, according to the option selected in enuCredStoreOption. Once connection has been attempted (whether successful or otherwise), a response event <a class="el" href="group___w_l_a_n_enums.html#gga064de09dec1d5e88ed8d075fa40f57deabb42b3025c56c51d915a1fa4abd2dbd0">M2M_WIFI_RESP_CON_STATE_CHANGED</a> will be sent to the callback function <a class="el" href="group___w_l_a_n_callbacks.html#ga736f9be563605a41689b47de03de14d0">tpfAppWifiCb</a> provided during initialization <a class="el" href="group__m2m__wifi.html#ga66f5bf5f84f898bdd4453f2717a3deb5">m2m_wifi_init</a>.</p>
<p>Possible results indicated by the response event are:</p><ul>
<li><a class="el" href="group___w_l_a_n_enums.html#gga460c311f58f4c40c3d20eec9e99db586a0c24dd073c9dde02e789858e161f7106">M2M_WIFI_DISCONNECTED</a> if the connection attempt failed.</li>
<li><a class="el" href="group___w_l_a_n_enums.html#gga460c311f58f4c40c3d20eec9e99db586a9196649c19ee10e2168e08a5b4785938">M2M_WIFI_CONNECTED</a> if the connection attempt succeeded.</li>
</ul>
<dl class="section pre"><dt>Precondition</dt><dd>Prior to attempting connection, the WINC driver must have been initialized by calling the <a class="el" href="group__m2m__wifi.html#ga66f5bf5f84f898bdd4453f2717a3deb5">m2m_wifi_init</a> function.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is handled in station mode only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">enuCredStoreOption</td><td>Option to specify whether connection details (i.e. the contents of pstrNetworkId and pstrAuthWep) are stored in WINC's flash and, if so, whether they are encrypted before storing.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pstrNetworkId</td><td>Structure specifying SSID/BSSID and Wi-Fi channel.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pstrAuthWep</td><td>Structure specifying the WEP key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns M2M_SUCCESS if the connect request has been successfully passed to the firmware and a negative value otherwise. </dd></dl>

</div>
</div>
<a id="ga739abd39f7befa0da7bcea564a726141"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga739abd39f7befa0da7bcea564a726141">&#9670;&nbsp;</a></span>m2m_wifi_default_connect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_wifi_default_connect </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronous API that attempts to reconnect to the last-associated access point. </p>
<p>Asynchronous Wi-Fi connection function. An application calling this function will cause the firmware to attempt to reconnect to the access point with which it had last successfully connected. A failure to connect will result in a response of <a class="el" href="group___w_l_a_n_enums.html#gga064de09dec1d5e88ed8d075fa40f57dea4757bdb5546f38fbd8213caffb9e1e1e">M2M_WIFI_RESP_DEFAULT_CONNECT</a> indicating a connection error as defined in the structure <a class="el" href="structtstr_m2_m_default_conn_resp.html">tstrM2MDefaultConnResp</a>.</p>
<p>Possible errors are: <a class="el" href="group___w_l_a_n_enums.html#gga6a91fa29dec13711074431422c220ae6ad0e6a25fe4d92c7f4847fc83a6ebf6c2">M2M_DEFAULT_CONN_EMPTY_LIST</a> indicating that the connection list is empty, or <a class="el" href="group___w_l_a_n_enums.html#gga6a91fa29dec13711074431422c220ae6ad21f428be96f28b6022b267fa7a12476">M2M_DEFAULT_CONN_SCAN_MISMATCH</a> indicating a mismatch for the saved AP name.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Prior to connecting, the WINC driver should have been successfully initialized by calling the <a class="el" href="group__m2m__wifi.html#ga66f5bf5f84f898bdd4453f2717a3deb5">m2m_wifi_init</a> function.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function must be called in station mode only. It is important to note that successful completion of a call to m2m_wifi_default_connect does not guarantee success of the WIFI connection; a negative return value indicates only locally-detected errors.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__m2m__wifi.html#ga39167bb6c3a20a24f46b387e7096d501" title="DEPRECATED in v19.6.1 - Kept only for legacy purposes.  Legacy asynchronous API to request connection...">m2m_wifi_connect</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns M2M_SUCCESS if the command has been successfully queued to the WINC and a negative value otherwise. </dd></dl>

</div>
</div>
<a id="ga748dfce4572adf510387302540c84ff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga748dfce4572adf510387302540c84ff0">&#9670;&nbsp;</a></span>m2m_wifi_deinit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_wifi_deinit </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pVArg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronous API to de-initialize the WINC driver and host interface. </p>
<p>De-initialization function for the WINC driver. De-initializes the host interface and frees any resources used by the M2M_WIFI layer. This function must be called in the application closing phase to ensure that all resources have been correctly released.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pVArg</td><td>Opaque argument, not used in current implementation. Application should use null.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns M2M_SUCCESS if the command has been successfully queued to the WINC, and a negative value otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function must be called at the de-initialization stage of the application. Generally this function should be the last function before switching off the chip and it should be followed only by <a class="el" href="group___a_d_a_p_t_e_r_init.html#ga5d2f45a1ab2419ed126aa387a7112a55">winc_adapter_deinit</a> function call. Every function call of <a class="el" href="group__m2m__wifi.html#ga66f5bf5f84f898bdd4453f2717a3deb5">m2m_wifi_init</a> should be matched with a call to m2m_wifi_deinit.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___a_d_a_p_t_e_r_init.html#ga5d2f45a1ab2419ed126aa387a7112a55" title="This function is used to de-initialize the ADAPTER and turn off the WINC board.">winc_adapter_deinit</a> <a class="el" href="group__m2m__wifi.html#ga66f5bf5f84f898bdd4453f2717a3deb5" title="Synchronous API to initialize the WINC driver.">m2m_wifi_init</a> <a class="el" href="group__m2m__wifi.html#ga12005142de3d7b4aee1b7091720715fe" title="First part of m2m_wifi_init, up to the point of initializing SPI for flash access.">m2m_wifi_init_hold</a> <a class="el" href="group__m2m__wifi.html#gaf3d21bf9d8318d038bfa6a5063a8e278" title="Second part of m2m_wifi_init, continuing from where m2m_wifi_init_hold left off.">m2m_wifi_init_start</a> <a class="el" href="group__m2m__wifi.html#ga1dfd77b592cbe00ce1f8576178f40ec6" title="Prepares the WINC before downloading any data (firmware, certificates, etc).">m2m_wifi_download_mode</a> <a class="el" href="group__m2m__wifi.html#ga1dfd77b592cbe00ce1f8576178f40ec6" title="Prepares the WINC before downloading any data (firmware, certificates, etc).">m2m_wifi_download_mode</a> </dd></dl>

</div>
</div>
<a id="ga2a9101bbe14718ef475e6085bafaf15e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a9101bbe14718ef475e6085bafaf15e">&#9670;&nbsp;</a></span>m2m_wifi_delete_sc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_wifi_delete_sc </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pcSsid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>u8SsidLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronous API that deletes connection credentials (PSK, WEP key, 802.1X password) from WINC flash. Either deletes all credentials, or for a specific SSID. </p>
<p>Causes WINC to delete connection credentials. If the parameter is NULL, then WINC will delete all credentials from flash. Otherwise WINC will only delete credentials for matching SSID. Callback will report the status of the operation (success or not).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pcSsid</td><td>SSID to match on when deleting credentials. SSID must not contain '\0'. NULL is a valid argument here, in which case all credentials are deleted.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">u8SsidLen</td><td>Length of SSID provided in pcSsid. Must be less than <a class="el" href="group___w_l_a_n_defines.html#gab2bd95c18ede2fbc07b44c5660cc0097">M2M_MAX_SSID_LEN</a>. This parameter is ignored if pcSsid is NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Prior to deleting credentials, the WINC driver should have been successfully initialized by calling the <a class="el" href="group__m2m__wifi.html#ga66f5bf5f84f898bdd4453f2717a3deb5">m2m_wifi_init</a> function.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The option to delete for a specific SSID is currently not supported; all credentials are deleted regardless of the input parameters.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns M2M_SUCCESS if the command has been successfully queued to the WINC and a negative value otherwise. </dd></dl>

</div>
</div>
<a id="gacefe61650b1cb0727aa6ce77e5efd087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacefe61650b1cb0727aa6ce77e5efd087">&#9670;&nbsp;</a></span>m2m_wifi_disable_ap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_wifi_disable_ap </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronous API to disable access point mode on the WINC. </p>
<p>Must be called only when the AP is enabled through the <a class="el" href="group__m2m__wifi.html#ga9479ba2f53700434b8f4b31363ddfa0c">m2m_wifi_enable_ap</a> function. Otherwise the call to this function will not be useful.</p>
<dl class="section return"><dt>Returns</dt><dd>The function returns M2M_SUCCESS if the command has been successfully queued to the WINC and a negative value otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__m2m__wifi.html#ga9479ba2f53700434b8f4b31363ddfa0c" title="Asynchronous API to enable access point (AKA &quot;hot-spot&quot;) mode on the WINC.">m2m_wifi_enable_ap</a> </dd></dl>

</div>
</div>
<a id="gacfae399c6a5bca4ff754cb57459d4de3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacfae399c6a5bca4ff754cb57459d4de3">&#9670;&nbsp;</a></span>m2m_wifi_disable_roaming()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_wifi_disable_roaming </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable WiFi STA roaming. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Must be called after the initialization.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns M2M_SUCCESS for successful operations and a negative value otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__m2m__wifi.html#ga66f5bf5f84f898bdd4453f2717a3deb5" title="Synchronous API to initialize the WINC driver.">m2m_wifi_init</a> </dd></dl>

</div>
</div>
<a id="ga6949ee7b771bfb0c4e0f160b98dadf7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6949ee7b771bfb0c4e0f160b98dadf7b">&#9670;&nbsp;</a></span>m2m_wifi_disconnect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_wifi_disconnect </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronous API to request disconnection from a network. </p>
<p>Request a Wi-Fi disconnect from the currently connected AP. The connection status will be indicated to the application via a <a class="el" href="group___w_l_a_n_enums.html#gga064de09dec1d5e88ed8d075fa40f57deabb42b3025c56c51d915a1fa4abd2dbd0">M2M_WIFI_RESP_CON_STATE_CHANGED</a> event. The status will be one of those defined in <a class="el" href="group___w_l_a_n_enums.html#ga460c311f58f4c40c3d20eec9e99db586">tenuM2mConnState</a>, with <a class="el" href="group___w_l_a_n_enums.html#gga460c311f58f4c40c3d20eec9e99db586a0c24dd073c9dde02e789858e161f7106">M2M_WIFI_DISCONNECTED</a> indicating a successful disconnection.</p>
<dl class="section return"><dt>Returns</dt><dd>The function returns M2M_SUCCESS if the command has been successfully queued to the WINC and a negative value otherwise.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Disconnection request must be made to a successfully connected AP. If the WINC is not in the connected state, a call to this function will hold insignificant.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function must be called in station mode only.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__m2m__wifi.html#ga8d684fd730f5175c281f3ac7a2b4eafa" title="Asynchronous API to connect to an access point using open authentication.">m2m_wifi_connect_open</a> <a class="el" href="group__m2m__wifi.html#gaf276c05ac4568cabafe9e0cf3861b154" title="Asynchronous API to connect to an access point using WEP authentication.">m2m_wifi_connect_wep</a> <a class="el" href="group__m2m__wifi.html#gaa131b2fb19e32077923852539b807a84" title="Asynchronous API to connect to an access point using WPA(2) PSK authentication.">m2m_wifi_connect_psk</a> <a class="el" href="group__m2m__wifi.html#ga8bdfa38e51644e958d866d5495fe8a98" title="Asynchronous API to connect to an access point using WPA(2) Enterprise authentication with MS-CHAP-V2...">m2m_wifi_connect_1x_mschap2</a> <a class="el" href="group__m2m__wifi.html#ga5b22373211fefea8a547f28f27f4a402" title="Asynchronous API to connect to an access point using WPA(2) Enterprise authentication with MS-CHAP-V2...">m2m_wifi_connect_1x_tls</a> <a class="el" href="group__m2m__wifi.html#ga739abd39f7befa0da7bcea564a726141" title="Asynchronous API that attempts to reconnect to the last-associated access point.">m2m_wifi_default_connect</a> </dd></dl>

</div>
</div>
<a id="ga1dfd77b592cbe00ce1f8576178f40ec6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1dfd77b592cbe00ce1f8576178f40ec6">&#9670;&nbsp;</a></span>m2m_wifi_download_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_wifi_download_mode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepares the WINC before downloading any data (firmware, certificates, etc). </p>
<p>This function should be called before attempting to download any data to the WINC. Performs the appropriate WINC driver initialization, this includes bus initialization, interrupt enabling and it halts the chip to allow for the firmware downloads. Firmware can be downloaded through a number of interfaces, UART, I2C and SPI.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Prior to call m2m_wifi_download_mode, the Application should ensure that the Wi-Fi is not initialized. This can be done by calling <a class="el" href="group__m2m__wifi.html#ga5372f7bc6a7bda4a40e0b9f979ed9a7f">m2m_wifi_get_state</a> and in case the Wi-Fi state differs from <a class="el" href="group___w_l_a_n_enums.html#gga6fd80a986c0ee128add6160889a3b2c2a3776f24e3a21d316e8876c59352ab1f1">WIFI_STATE_DEINIT</a>, a <a class="el" href="group__m2m__wifi.html#ga748dfce4572adf510387302540c84ff0">m2m_wifi_deinit</a> needs to be issued.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns M2M_SUCCESS for successful operations and a negative value otherwise. </dd></dl>

</div>
</div>
<a id="ga9479ba2f53700434b8f4b31363ddfa0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9479ba2f53700434b8f4b31363ddfa0c">&#9670;&nbsp;</a></span>m2m_wifi_enable_ap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_wifi_enable_ap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtstr_m2_m_a_p_config.html">tstrM2MAPConfig</a> *&#160;</td>
          <td class="paramname"><em>pstrM2MAPConfig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronous API to enable access point (AKA "hot-spot") mode on the WINC. </p>
<p>The WINC supports the ability to operate as an access point with the following limitations:</p><ul>
<li>Only 1 station may be associated at any given time.</li>
<li>Open system and WEP are the only security suites supported.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pstrM2MAPConfig</td><td>A structure holding the AP configurations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns M2M_SUCCESS if the command has been successfully queued to the WINC and a negative value otherwise.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is not allowed in STA modes.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>A Wi-Fi notification callback of type <a class="el" href="group___w_l_a_n_callbacks.html#ga736f9be563605a41689b47de03de14d0">tpfAppWifiCb</a> MUST be implemented and registered at initialization. Registering the callback is done through passing it to the <a class="el" href="group__m2m__wifi.html#ga66f5bf5f84f898bdd4453f2717a3deb5">m2m_wifi_init</a>.</li>
<li>The event <a class="el" href="group___w_l_a_n_enums.html#gga064de09dec1d5e88ed8d075fa40f57deaa849449fa83e4b552689266a1f1019e7">M2M_WIFI_REQ_DHCP_CONF</a> must be handled in the callback.</li>
<li>The <a class="el" href="group__m2m__wifi.html#gae397199d8523f172b33309b82c34c2af">m2m_wifi_handle_events</a> MUST be called to receive the responses in the callback.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___w_l_a_n_callbacks.html#ga736f9be563605a41689b47de03de14d0" title="This is the main callback function for the Wi-Fi driver and is responsible for processing any M2M_WIF...">tpfAppWifiCb</a> <a class="el" href="group___w_l_a_n_enums.html#gaa232a09c953ec8200c13774f94107b05" title="This enum contains all the supported Wi-Fi security types.">tenuM2mSecType</a> <a class="el" href="group__m2m__wifi.html#ga66f5bf5f84f898bdd4453f2717a3deb5" title="Synchronous API to initialize the WINC driver.">m2m_wifi_init</a> <a class="el" href="group___w_l_a_n_enums.html#gga064de09dec1d5e88ed8d075fa40f57deaa849449fa83e4b552689266a1f1019e7">M2M_WIFI_REQ_DHCP_CONF</a> <a class="el" href="structtstr_m2m_wifi_state_changed.html" title="This struct contains the Wi-Fi connection state.">tstrM2mWifiStateChanged</a> <a class="el" href="structtstr_m2_m_a_p_config.html" title="This structure holds the configuration parameters for the AP mode. It should be set by the applicatio...">tstrM2MAPConfig</a></dd></dl>
<h1><a class="anchor" id="WIFIExample5"></a>
Example</h1>
<p>The code snippet demonstrates how the AP mode is enabled after the driver is initialized in the application's main function and the handling of the event <a class="el" href="group___w_l_a_n_enums.html#gga064de09dec1d5e88ed8d075fa40f57deaa849449fa83e4b552689266a1f1019e7">M2M_WIFI_REQ_DHCP_CONF</a>, to indicate successful connection.</p>
<div class="fragment"></div><!-- fragment --> 
</div>
</div>
<a id="ga9edfcc6247a767e2528efd23a39b700e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9edfcc6247a767e2528efd23a39b700e">&#9670;&nbsp;</a></span>m2m_wifi_enable_ap_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_wifi_enable_ap_ext </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtstr_m2_m_a_p_mode_config.html">tstrM2MAPModeConfig</a> *&#160;</td>
          <td class="paramname"><em>pstrM2MAPModeConfig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronous API to enable access point (AKA "hot-spot") mode on the WINC IC with extended options. </p>
<p>The WINC IC supports the ability to operate as an access point with the following limitations:</p><ul>
<li>Only 1 station may be associated at any given time.</li>
<li>Open system and WEP are the only security suites supported.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pstrM2MAPModeConfig</td><td>A structure holding the AP configurations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns M2M_SUCCESS if the command has been successfully queued to the WINC and a negative value otherwise.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>A Wi-Fi notification callback of type <a class="el" href="group___w_l_a_n_callbacks.html#ga736f9be563605a41689b47de03de14d0">tpfAppWifiCb</a> MUST be implemented and registered at initialization. Registering the callback is done through passing it to the <a class="el" href="group__m2m__wifi.html#ga66f5bf5f84f898bdd4453f2717a3deb5">m2m_wifi_init</a>.</li>
<li>The event <a class="el" href="group___w_l_a_n_enums.html#gga064de09dec1d5e88ed8d075fa40f57deaa849449fa83e4b552689266a1f1019e7">M2M_WIFI_REQ_DHCP_CONF</a> must be handled in the callback.</li>
<li>The <a class="el" href="group__m2m__wifi.html#gae397199d8523f172b33309b82c34c2af">m2m_wifi_handle_events</a> MUST be called to receive the responses in the callback.</li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is not allowed in STA mode.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___w_l_a_n_callbacks.html#ga736f9be563605a41689b47de03de14d0" title="This is the main callback function for the Wi-Fi driver and is responsible for processing any M2M_WIF...">tpfAppWifiCb</a> <a class="el" href="group___w_l_a_n_enums.html#gaa232a09c953ec8200c13774f94107b05" title="This enum contains all the supported Wi-Fi security types.">tenuM2mSecType</a> <a class="el" href="group__m2m__wifi.html#ga66f5bf5f84f898bdd4453f2717a3deb5" title="Synchronous API to initialize the WINC driver.">m2m_wifi_init</a> <a class="el" href="group___w_l_a_n_enums.html#gga064de09dec1d5e88ed8d075fa40f57deaa849449fa83e4b552689266a1f1019e7">M2M_WIFI_REQ_DHCP_CONF</a> <a class="el" href="structtstr_m2m_wifi_state_changed.html" title="This struct contains the Wi-Fi connection state.">tstrM2mWifiStateChanged</a> <a class="el" href="structtstr_m2_m_a_p_mode_config.html" title="AP Configuration.">tstrM2MAPModeConfig</a> <a class="el" href="structtstr_m2_m_a_p_config_ext.html" title="AP Configuration Extension.">tstrM2MAPConfigExt</a></dd></dl>
<h1><a class="anchor" id="WIFIExample5b"></a>
Example</h1>
<p>The code snippet demonstrates how the AP mode is enabled after the driver is initialized in the application's main function and the handling of the event <a class="el" href="group___w_l_a_n_enums.html#gga064de09dec1d5e88ed8d075fa40f57deaa849449fa83e4b552689266a1f1019e7">M2M_WIFI_REQ_DHCP_CONF</a>, to indicate successful connection.</p>
<div class="fragment"></div><!-- fragment --> 
</div>
</div>
<a id="gaee8e0e7b992d84bd0762dfbb48e6aaf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee8e0e7b992d84bd0762dfbb48e6aaf7">&#9670;&nbsp;</a></span>m2m_wifi_enable_dhcp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_wifi_enable_dhcp </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>u8DhcpEn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronous function to control the DHCP client functionality within the WINC. </p>
<p>This function allows the application to control the behaviour of the DHCP client function within the WINC once it has associated with an access point. DHCP client functionality is enabled by default.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">u8DhcpEn</td><td>The state of the DHCP client feature after successful association with an access point:<ul>
<li>1: Enables DHCP client after connection.</li>
<li>0: Disables DHCP client after connection.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns M2M_SUCCESS for successful operation and a negative value otherwise.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>DHCP client is enabled by default. This Function should be called to disable DHCP client operation before using <a class="el" href="group__m2m__wifi.html#ga6c4c223a4eb484298c3742d40eb3c2f7">m2m_wifi_set_static_ip</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__m2m__wifi.html#ga6c4c223a4eb484298c3742d40eb3c2f7" title="Asynchronous API to manually assign a (static) IP address to the WINC.">m2m_wifi_set_static_ip</a> </dd></dl>

</div>
</div>
<a id="ga6e86dfc3d6d3c7fdf540b42a1e6f0824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e86dfc3d6d3c7fdf540b42a1e6f0824">&#9670;&nbsp;</a></span>m2m_wifi_enable_firmware_logs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_wifi_enable_firmware_logs </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>u8Enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or Disable logs in run time. </p>
<p>Enable or Disable logs in run time (Disable Firmware logs will enhance the firmware start-up time and performance).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">u8Enable</td><td>Set 1 to enable the logs, 0 for disable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Must be called after initialization through the following function <a class="el" href="group__m2m__wifi.html#ga66f5bf5f84f898bdd4453f2717a3deb5">m2m_wifi_init</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns M2M_SUCCESS for success and a negative value otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><b>DISABLE_FIRMWARE_LOGS</b> (build option to disable logs from initializations) <a class="el" href="group__m2m__wifi.html#ga66f5bf5f84f898bdd4453f2717a3deb5" title="Synchronous API to initialize the WINC driver.">m2m_wifi_init</a> </dd></dl>

</div>
</div>
<a id="gafb0fb11fb86774ba0c56982cf4d43fe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb0fb11fb86774ba0c56982cf4d43fe0">&#9670;&nbsp;</a></span>m2m_wifi_enable_roaming()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_wifi_enable_roaming </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>u8EnableDhcp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable WiFi STA roaming. </p>
<p>m2m_wifi_enable_roaming enables the firmware to trigger the roaming algorithm/steps on link loss with the current AP. If roaming is successful, the <a class="el" href="group___w_l_a_n_enums.html#gga064de09dec1d5e88ed8d075fa40f57deabb42b3025c56c51d915a1fa4abd2dbd0">M2M_WIFI_RESP_CON_STATE_CHANGED</a> message with state as <a class="el" href="group___w_l_a_n_enums.html#gga460c311f58f4c40c3d20eec9e99db586ac6bdf0e31a4c380a9371ef71086b5825">M2M_WIFI_ROAMED</a> is sent to host. Additionally a <a class="el" href="group___w_l_a_n_enums.html#gga064de09dec1d5e88ed8d075fa40f57deaa849449fa83e4b552689266a1f1019e7">M2M_WIFI_REQ_DHCP_CONF</a> message with new DHCP lease details is sent to host (only if u8EnableDhcp=1). If roaming is unsuccessful, <a class="el" href="group___w_l_a_n_enums.html#gga064de09dec1d5e88ed8d075fa40f57deabb42b3025c56c51d915a1fa4abd2dbd0">M2M_WIFI_RESP_CON_STATE_CHANGED</a> message with state as <a class="el" href="group___w_l_a_n_enums.html#gga460c311f58f4c40c3d20eec9e99db586a0c24dd073c9dde02e789858e161f7106">M2M_WIFI_DISCONNECTED</a> is sent to host.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">u8EnableDhcp</td><td>0 : Disables DHCP client execution after roaming to new AP 1 : Enables DHCP client execution after roaming to new AP</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Must be called after the initialization. The roaming algorithm/procedure is internal to the firmware.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns M2M_SUCCESS for successful operations and a negative value otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__m2m__wifi.html#ga66f5bf5f84f898bdd4453f2717a3deb5" title="Synchronous API to initialize the WINC driver.">m2m_wifi_init</a> </dd></dl>

</div>
</div>
<a id="ga97cd0378aa47bc3039ab0e30c926155a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97cd0378aa47bc3039ab0e30c926155a">&#9670;&nbsp;</a></span>m2m_wifi_enable_sntp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_wifi_enable_sntp </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>u8Enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronous API to enable or disable the native Simple Network Time Protocol(SNTP) client running on the WINC. </p>
<p>The SNTP client is enabled by default during chip initialization. This function can be used to disable or subsequently re-enable the service.</p>
<p>The service is capable of synchronizing the WINC system clock to the UTC time from a well-known (and trusted) time server, for example "time.nist.gov". By default the SNTP client will update the system time once every 24 hours. The ability to track the time accurately is important for various applications such as checking expiry of X509 certificates during TLS (Transport Layer Security) session establishment.</p>
<p>It is highly recommended to leave SNTP enabled if there is no alternative source of timing information. For systems including an RTC device, SNTP may not be needed and the WINC's time may be set using the <a class="el" href="group__m2m__wifi.html#ga4055ecd51b8c38e427d9f418f1743712">m2m_wifi_set_system_time</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">u8Enable</td><td>Enables or disables the SNTP service '0' :disable SNTP '1' :enable SNTP</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns M2M_SUCCESS if the command has been successfully queued to the WINC and a negative value otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__m2m__wifi.html#ga4055ecd51b8c38e427d9f418f1743712" title="Asynchronous function for setting the system time within the WINC.">m2m_wifi_set_system_time</a> </dd></dl>

</div>
</div>
<a id="gabe55ce43f9508f29eade37afa68c2bf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe55ce43f9508f29eade37afa68c2bf2">&#9670;&nbsp;</a></span>m2m_wifi_get_connection_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_wifi_get_connection_info </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronous API for retrieving the WINC connection status. </p>
<p>Requests the connection status from the WINC including information regarding any access point to which it is currently connected, or any non-AP station that is connected to the WINC. All information will be returned to the application via the Wi-Fi notification callback through the event <a class="el" href="group___w_l_a_n_enums.html#gga57466b36df595c593e7ccc9892e14b20a35767ad0217ab92b149bc77e79610d33">M2M_WIFI_RESP_CONN_INFO</a>.</p>
<p>The connection info can be retrieved using the structure <a class="el" href="structtstr_m2_m_conn_info.html">tstrM2MConnInfo</a> which contains:</p><ul>
<li>Connection Security</li>
<li>Connection RSSI</li>
<li>Remote MAC address</li>
<li>Remote IP address</li>
<li>SSID of the network (in cases where the WINC is in non-AP mode)</li>
</ul>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>A Wi-Fi notification callback of type <a class="el" href="group___w_l_a_n_callbacks.html#ga736f9be563605a41689b47de03de14d0">tpfAppWifiCb</a> MUST be implemented and registered at startup. Registering the callback is done through passing it to the initialization <a class="el" href="group__m2m__wifi.html#ga66f5bf5f84f898bdd4453f2717a3deb5">m2m_wifi_init</a> function.</li>
<li>The event <a class="el" href="group___w_l_a_n_enums.html#gga57466b36df595c593e7ccc9892e14b20a35767ad0217ab92b149bc77e79610d33">M2M_WIFI_RESP_CONN_INFO</a> must be handled in the callback to receive the requested connection info.</li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd><ul>
<li>In case the WINC is operating in AP mode, the SSID field will be returned as a NULL string.</li>
</ul>
</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns M2M_SUCCESS if the command has been successfully queued to the WINC and a negative value otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___w_l_a_n_enums.html#gga57466b36df595c593e7ccc9892e14b20a35767ad0217ab92b149bc77e79610d33">M2M_WIFI_RESP_CONN_INFO</a>, <a class="el" href="structtstr_m2_m_conn_info.html" title="This struct contains the connection information.">tstrM2MConnInfo</a> </dd></dl>
<h1><a class="anchor" id="WIFIExample2"></a>
Example</h1>
<p>The code snippet shows an example of how Wi-Fi connection information is retrieved .</p>
<div class="fragment"></div><!-- fragment --> 
</div>
</div>
<a id="gac0ca8bc0a8c78acaa115ddb677f55401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0ca8bc0a8c78acaa115ddb677f55401">&#9670;&nbsp;</a></span>m2m_wifi_get_firmware_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_wifi_get_firmware_version </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtstr_m2m_rev.html">tstrM2mRev</a> *&#160;</td>
          <td class="paramname"><em>pstrRev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronous API to obtain the firmware version currently running on the WINC. </p>
<p>Get the Firmware version info from the active partition, as defined in the structure <a class="el" href="structtstr_m2m_rev.html">tstrM2mRev</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pstrRev</td><td>Pointer to a variable of type <a class="el" href="structtstr_m2m_rev.html">tstrM2mRev</a>, which contains the firmware version parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns M2M_SUCCESS for success and a negative value otherwise.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Must be called after initialization through the following function <a class="el" href="group__m2m__wifi.html#ga66f5bf5f84f898bdd4453f2717a3deb5">m2m_wifi_init</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__m2m__wifi.html#ga66f5bf5f84f898bdd4453f2717a3deb5" title="Synchronous API to initialize the WINC driver.">m2m_wifi_init</a> </dd></dl>

</div>
</div>
<a id="ga00be821aaad96330c8472838c1b8570f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00be821aaad96330c8472838c1b8570f">&#9670;&nbsp;</a></span>m2m_wifi_get_mac_address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_wifi_get_mac_address </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pu8MacAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronous API to retrieve the MAC address currently in use by the device. </p>
<p>This function obtains the MAC address that is currently in use by the device. If the function returns with M2M_SUCCESS then the content of the memory referenced by pu8MacAddr will be populated with the 6 byte MAC address; otherwise, that memory will be left unchanged.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Prior call to <a class="el" href="group__m2m__wifi.html#ga66f5bf5f84f898bdd4453f2717a3deb5">m2m_wifi_init</a> is required before any WIFI/socket function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pu8MacAddr</td><td>Pointer to a buffer in memory containing a 6-byte MAC address (provided function returns M2M_SUCCESS).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns M2M_SUCCESS for successful operation and a negative value otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__m2m__wifi.html#ga2fc47dc397a4e9d9213ec40f9ba2bb19" title="Synchronous API to query the MAC address programmed into the WINC OTP memory.">m2m_wifi_get_otp_mac_address</a> </dd></dl>

</div>
</div>
<a id="ga1638306107bf997ec4df62a473dba3b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1638306107bf997ec4df62a473dba3b4">&#9670;&nbsp;</a></span>m2m_wifi_get_num_ap_found()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t m2m_wifi_get_num_ap_found </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronous function to retrieve the number of AP's found during the last scan operation. </p>
<p>The function reads the number of APs from global variable which was updated in the Wi-Fi callback function through the <a class="el" href="group___w_l_a_n_enums.html#gga57466b36df595c593e7ccc9892e14b20ad835febbe18b7e3cc6ce4693951354fe">M2M_WIFI_RESP_SCAN_DONE</a> event. Function used only in STA mode only.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__m2m__wifi.html#ga39eab477f1dbb3b2a768d8a0fdc45b27" title="Asynchronous API to request the WINC to scan for networks.">m2m_wifi_request_scan</a> <a class="el" href="group___w_l_a_n_enums.html#gga57466b36df595c593e7ccc9892e14b20ad835febbe18b7e3cc6ce4693951354fe">M2M_WIFI_RESP_SCAN_DONE</a> <a class="el" href="group___w_l_a_n_enums.html#gga57466b36df595c593e7ccc9892e14b20adfb48e88c3a8e5f9dac634d62d3f53e5">M2M_WIFI_RESP_SCAN_RESULT</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>m2m_wifi_request_scan must be called first to ensure up to date results are available.<ul>
<li>A Wi-Fi notification callback of type <a class="el" href="group___w_l_a_n_callbacks.html#ga736f9be563605a41689b47de03de14d0">tpfAppWifiCb</a> MUST be implemented and registered at initialization. Registering the callback is done through passing it to the <a class="el" href="group__m2m__wifi.html#ga66f5bf5f84f898bdd4453f2717a3deb5">m2m_wifi_init</a>.</li>
<li>The event <a class="el" href="group___w_l_a_n_enums.html#gga57466b36df595c593e7ccc9892e14b20ad835febbe18b7e3cc6ce4693951354fe">M2M_WIFI_RESP_SCAN_DONE</a> must be handled in the callback to receive the requested scan information.</li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function must be called only in the Wi-Fi callback function when the events <a class="el" href="group___w_l_a_n_enums.html#gga57466b36df595c593e7ccc9892e14b20ad835febbe18b7e3cc6ce4693951354fe">M2M_WIFI_RESP_SCAN_DONE</a> or <a class="el" href="group___w_l_a_n_enums.html#gga57466b36df595c593e7ccc9892e14b20adfb48e88c3a8e5f9dac634d62d3f53e5">M2M_WIFI_RESP_SCAN_RESULT</a> are received. Calling this function in any other place will result in undefined/outdated numbers.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of AP's found in the last Scan Request.</dd></dl>
<h1><a class="anchor" id="WIFIExample7"></a>
Example</h1>
<p>The code snippet demonstrates an example of how the scan request is called from the application's main function and the handling of the events received in response.</p>
<div class="fragment"></div><!-- fragment --> 
</div>
</div>
<a id="ga2fc47dc397a4e9d9213ec40f9ba2bb19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2fc47dc397a4e9d9213ec40f9ba2bb19">&#9670;&nbsp;</a></span>m2m_wifi_get_otp_mac_address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_wifi_get_otp_mac_address </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pu8MacAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pu8IsValid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronous API to query the MAC address programmed into the WINC OTP memory. </p>
<p>This function attempts to read the device's MAC address from the One Time Programmable (OTP) memory on the WINC. The presence (yes or no) of a MAC address in the OTP memory and, in the case of it being present, its value is returned via RAM pointed to by the input arguments.</p>
<p>Request the MAC address stored on the One Time Programmable(OTP) memory of the device. The function is blocking until the response is received.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Prior call to <a class="el" href="group__m2m__wifi.html#ga66f5bf5f84f898bdd4453f2717a3deb5">m2m_wifi_init</a> is required before any WIFI/socket function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pu8MacAddr</td><td>Output MAC address buffer 6 bytes in size. Valid only if *pu8Valid=1.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pu8IsValid</td><td>A boolean value set by the callee to indicate the validity of pu8MacAddr in OTP. If no MAC has been programmed in the OTP the value of this parameter will be zero; otherwise it will be non-zero.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns M2M_SUCCESS for success and a negative value otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__m2m__wifi.html#ga00be821aaad96330c8472838c1b8570f" title="Synchronous API to retrieve the MAC address currently in use by the device.">m2m_wifi_get_mac_address</a> </dd></dl>

</div>
</div>
<a id="gac53a9e3e4cd24b318e4e3722c5afb4ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac53a9e3e4cd24b318e4e3722c5afb4ed">&#9670;&nbsp;</a></span>m2m_wifi_get_sleep_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t m2m_wifi_get_sleep_mode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronous API to retrieve the current power save mode of the WINC. </p>
<dl class="section return"><dt>Returns</dt><dd>The current operating power saving mode. The value will be one of those from the enumerated type <a class="el" href="group___w_l_a_n_enums.html#gae6bd0ac78bfca4cda17d9dbedf79ad7e">tenuPowerSaveModes</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___w_l_a_n_enums.html#gae6bd0ac78bfca4cda17d9dbedf79ad7e" title="This enum contains all the supported Wi-Fi Power Save modes.">tenuPowerSaveModes</a> <a class="el" href="group__m2m__wifi.html#ga38ba065f25bf5cc2bbd35d6498121192" title="Synchronous API to set the power-save mode of the WINC.">m2m_wifi_set_sleep_mode</a> </dd></dl>

</div>
</div>
<a id="ga5372f7bc6a7bda4a40e0b9f979ed9a7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5372f7bc6a7bda4a40e0b9f979ed9a7f">&#9670;&nbsp;</a></span>m2m_wifi_get_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t m2m_wifi_get_state </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the Wi-Fi state. </p>
<dl class="section return"><dt>Returns</dt><dd>The function returns the current Wi-Fi state (see <a class="el" href="group___w_l_a_n_enums.html#ga6fd80a986c0ee128add6160889a3b2c2">tenuWifiState</a> for the possible states).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Check the WINC state. See <a class="el" href="group___w_l_a_n_enums.html#ga6fd80a986c0ee128add6160889a3b2c2">tenuWifiState</a> for possible states.<br  />
 <a class="el" href="group___w_l_a_n_enums.html#gga6fd80a986c0ee128add6160889a3b2c2a9a0f4ef2c87d5a1730b0e632eb30a00a">WIFI_STATE_INIT</a> state represents WINC initialized but not started, this is a suitable state for safe flash access.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__m2m__wifi.html#ga66f5bf5f84f898bdd4453f2717a3deb5" title="Synchronous API to initialize the WINC driver.">m2m_wifi_init</a> <a class="el" href="group__m2m__wifi.html#ga1dfd77b592cbe00ce1f8576178f40ec6" title="Prepares the WINC before downloading any data (firmware, certificates, etc).">m2m_wifi_download_mode</a> </dd></dl>

</div>
</div>
<a id="ga57394f15ef7d7c5a273776870680b9c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57394f15ef7d7c5a273776870680b9c3">&#9670;&nbsp;</a></span>m2m_wifi_get_system_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_wifi_get_system_time </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronous API to obtain the system time in use by the WINC. </p>
<p>This function will request the WINC to report its current system time to the application. The information will arrive at the application via the <a class="el" href="group___w_l_a_n_callbacks.html#ga736f9be563605a41689b47de03de14d0">tpfAppWifiCb</a> and event <a class="el" href="group___w_l_a_n_enums.html#gga57466b36df595c593e7ccc9892e14b20ae79e6ab974502efae44b37b2ac620190">M2M_WIFI_RESP_GET_SYS_TIME</a>. Response time retrieved is parsed into the members defined in the structure <a class="el" href="structtstr_system_time.html">tstrSystemTime</a>.</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>A Wi-Fi notification callback of type <a class="el" href="group___w_l_a_n_callbacks.html#ga736f9be563605a41689b47de03de14d0">tpfAppWifiCb</a> MUST be implemented and registered during initialization. Registration of the callback is done via the <a class="el" href="group__m2m__wifi.html#ga66f5bf5f84f898bdd4453f2717a3deb5">m2m_wifi_init</a> API.</li>
<li>The event <a class="el" href="group___w_l_a_n_enums.html#gga57466b36df595c593e7ccc9892e14b20ae79e6ab974502efae44b37b2ac620190">M2M_WIFI_RESP_GET_SYS_TIME</a> must be handled in the callback.</li>
</ul>
</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns M2M_SUCCESS if the command has been successfully queued to the WINC and a negative value otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__m2m__wifi.html#ga97cd0378aa47bc3039ab0e30c926155a" title="Asynchronous API to enable or disable the native Simple Network Time Protocol(SNTP) client running on...">m2m_wifi_enable_sntp</a> <a class="el" href="structtstr_system_time.html" title="This struct contains the system time.">tstrSystemTime</a> </dd></dl>

</div>
</div>
<a id="gae397199d8523f172b33309b82c34c2af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae397199d8523f172b33309b82c34c2af">&#9670;&nbsp;</a></span>m2m_wifi_handle_events()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_wifi_handle_events </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pVArg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronous M2M event handler function. </p>
<p>This function is responsible for handling interrupts received from the WINC firmware. Applications should call this function periodically in-order to receive the events that are to be handled by the callback functions implemented by the application.</p>
<p>Handle the various events received from the WINC. Whenever an event happens in the WINC (e.g. Connection, Disconnection, DHCP, etc), the WINC will interrupt the host to let it know that a new event has occurred. The host driver will attempt to handle these events whenever the application decides to do so by calling the m2m_wifi_handle_events function. It is mandatory to call this function periodically and independently of any other condition. It is ideal to include this function in the main and the most frequent loop of the host application.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pVArg</td><td>Opaque argument, not used in current implementation. Application should use null.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Prior to receiving events, the WINC driver should have been successfully initialized by calling the <a class="el" href="group__m2m__wifi.html#ga66f5bf5f84f898bdd4453f2717a3deb5">m2m_wifi_init</a> function.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Failure to successfully complete this function indicates bus errors and hence a fatal error that will prevent the application from proceeding.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns M2M_SUCCESS for successful interrupt handling and a negative value otherwise. </dd></dl>

</div>
</div>
<a id="ga66f5bf5f84f898bdd4453f2717a3deb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66f5bf5f84f898bdd4453f2717a3deb5">&#9670;&nbsp;</a></span>m2m_wifi_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_wifi_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtstr_wifi_init_param.html">tstrWifiInitParam</a> *&#160;</td>
          <td class="paramname"><em>pWifiInitParam</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronous API to initialize the WINC driver. </p>
<p>This function initializes the WINC driver by registering the callback function for the M2M_WIFI layer (also the callback function for bypass mode/monitoring mode if defined), initializing the host interface layer and the bus interfaces. Wi-Fi callback registering is essential to allow the handling of the events received, in response to the asynchronous Wi-Fi operations.</p>
<p>The possible Wi-Fi events that are expected to be received through the callback function (provided by the application) to the M2M_WIFI layer are listed below:</p>
<ul>
<li><a class="el" href="group___w_l_a_n_enums.html#gga064de09dec1d5e88ed8d075fa40f57deabb42b3025c56c51d915a1fa4abd2dbd0">M2M_WIFI_RESP_CON_STATE_CHANGED</a></li>
<li><a class="el" href="group___w_l_a_n_enums.html#gga57466b36df595c593e7ccc9892e14b20a35767ad0217ab92b149bc77e79610d33">M2M_WIFI_RESP_CONN_INFO</a></li>
<li><a class="el" href="group___w_l_a_n_enums.html#gga064de09dec1d5e88ed8d075fa40f57deaa849449fa83e4b552689266a1f1019e7">M2M_WIFI_REQ_DHCP_CONF</a></li>
<li><a class="el" href="group___w_l_a_n_enums.html#gga064de09dec1d5e88ed8d075fa40f57dea092328f1505213c9ab290f1e2482d69e">M2M_WIFI_REQ_WPS</a></li>
<li><a class="el" href="group___w_l_a_n_enums.html#gga064de09dec1d5e88ed8d075fa40f57deadeac372bffcc8d8f4db24d4bd0ecdde5">M2M_WIFI_RESP_IP_CONFLICT</a></li>
<li><a class="el" href="group___w_l_a_n_enums.html#gga57466b36df595c593e7ccc9892e14b20ad835febbe18b7e3cc6ce4693951354fe">M2M_WIFI_RESP_SCAN_DONE</a></li>
<li><a class="el" href="group___w_l_a_n_enums.html#gga57466b36df595c593e7ccc9892e14b20adfb48e88c3a8e5f9dac634d62d3f53e5">M2M_WIFI_RESP_SCAN_RESULT</a></li>
<li><a class="el" href="group___w_l_a_n_enums.html#gga57466b36df595c593e7ccc9892e14b20ae2f28d3ff5c4356502abfc26d8f6e5f1">M2M_WIFI_RESP_CURRENT_RSSI</a></li>
<li><a class="el" href="group___w_l_a_n_enums.html#gga05ce3ed74e4bf812904f45771ef101b2a2f500dee36058b56a0ffc6ba28876337">M2M_WIFI_RESP_CLIENT_INFO</a></li>
<li><a class="el" href="group___w_l_a_n_enums.html#gga57466b36df595c593e7ccc9892e14b20a4b4a55c41771f106a578b7253c63dede">M2M_WIFI_RESP_PROVISION_INFO</a></li>
<li><a class="el" href="group___w_l_a_n_enums.html#gga064de09dec1d5e88ed8d075fa40f57dea4757bdb5546f38fbd8213caffb9e1e1e">M2M_WIFI_RESP_DEFAULT_CONNECT</a></li>
<li><a class="el" href="group___w_l_a_n_enums.html#gga57466b36df595c593e7ccc9892e14b20a2d2336ccd8bfda6e083b0ec6b8d798ba">M2M_WIFI_RESP_ETHERNET_RX_PACKET</a> (if bypass mode is enabled)</li>
<li><a class="el" href="group___w_l_a_n_enums.html#gga064de09dec1d5e88ed8d075fa40f57dea9a121b41defa5ffcb174fe304cbce432">M2M_WIFI_RESP_WIFI_RX_PACKET</a> (if monitoring mode is enabled)</li>
</ul>
<p>Any application using the WINC driver must call this function at the start of its main function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pWifiInitParam</td><td>This is a pointer to a structure of type <a class="el" href="structtstr_wifi_init_param.html">tstrWifiInitParam</a> which contains pointers to the application WIFI layer callback function, monitoring mode callback and <a class="el" href="structtstr_eth_init_param.html">tstrEthInitParam</a> structure (which contains initialization settings for bypass mode).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns M2M_SUCCESS for successful operations and a negative value otherwise.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Prior to this function call, the application should initialize the ADAPTER using <a class="el" href="group___a_d_a_p_t_e_r_init.html#gada130f85323762ecde53e30136be7182">winc_adapter_init</a>. Also, the application must provide a callback function responsible for receiving all the Wi-Fi events that are received on the M2M_WIFI layer.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Failure to successfully complete indicates that the driver could not be initialized and a fatal error will prevent the application from proceeding, proper error handling should be implemented by the application.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__m2m__wifi.html#ga748dfce4572adf510387302540c84ff0" title="Synchronous API to de-initialize the WINC driver and host interface.">m2m_wifi_deinit</a> <a class="el" href="group__m2m__wifi.html#ga12005142de3d7b4aee1b7091720715fe" title="First part of m2m_wifi_init, up to the point of initializing SPI for flash access.">m2m_wifi_init_hold</a> <a class="el" href="group__m2m__wifi.html#gaf3d21bf9d8318d038bfa6a5063a8e278" title="Second part of m2m_wifi_init, continuing from where m2m_wifi_init_hold left off.">m2m_wifi_init_start</a> <a class="el" href="group__m2m__wifi.html#ga1dfd77b592cbe00ce1f8576178f40ec6" title="Prepares the WINC before downloading any data (firmware, certificates, etc).">m2m_wifi_download_mode</a> <a class="el" href="structtstr_wifi_init_param.html" title="Structure, holding the Wi-fi configuration attributes such as the Wi-Fi callback ,...">tstrWifiInitParam</a> <a class="el" href="group___w_l_a_n_enums.html#ga064de09dec1d5e88ed8d075fa40f57de" title="This enum contains WINC commands while in Station mode.">tenuM2mStaCmd</a> </dd></dl>

</div>
</div>
<a id="ga12005142de3d7b4aee1b7091720715fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12005142de3d7b4aee1b7091720715fe">&#9670;&nbsp;</a></span>m2m_wifi_init_hold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_wifi_init_hold </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>First part of <a class="el" href="group__m2m__wifi.html#ga66f5bf5f84f898bdd4453f2717a3deb5">m2m_wifi_init</a>, up to the point of initializing SPI for flash access. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__m2m__wifi.html#ga66f5bf5f84f898bdd4453f2717a3deb5" title="Synchronous API to initialize the WINC driver.">m2m_wifi_init</a> <a class="el" href="group__m2m__wifi.html#ga748dfce4572adf510387302540c84ff0" title="Synchronous API to de-initialize the WINC driver and host interface.">m2m_wifi_deinit</a> <a class="el" href="group__m2m__wifi.html#gaf3d21bf9d8318d038bfa6a5063a8e278" title="Second part of m2m_wifi_init, continuing from where m2m_wifi_init_hold left off.">m2m_wifi_init_start</a> <a class="el" href="group__m2m__wifi.html#ga1dfd77b592cbe00ce1f8576178f40ec6" title="Prepares the WINC before downloading any data (firmware, certificates, etc).">m2m_wifi_download_mode</a> </dd></dl>

</div>
</div>
<a id="gaf3d21bf9d8318d038bfa6a5063a8e278"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3d21bf9d8318d038bfa6a5063a8e278">&#9670;&nbsp;</a></span>m2m_wifi_init_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_wifi_init_start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtstr_wifi_init_param.html">tstrWifiInitParam</a> *&#160;</td>
          <td class="paramname"><em>pWifiInitParam</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Second part of <a class="el" href="group__m2m__wifi.html#ga66f5bf5f84f898bdd4453f2717a3deb5">m2m_wifi_init</a>, continuing from where <a class="el" href="group__m2m__wifi.html#ga12005142de3d7b4aee1b7091720715fe">m2m_wifi_init_hold</a> left off. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pWifiInitParam</td><td>This is a pointer to a variable of type <a class="el" href="structtstr_wifi_init_param.html">tstrWifiInitParam</a> which contains pointers to the application WIFI layer callback function (see <a class="el" href="group___w_l_a_n_callbacks.html#ga736f9be563605a41689b47de03de14d0">tpfAppWifiCb</a>), monitoring mode callback (see <a class="el" href="group___w_l_a_n_callbacks.html#ga5884506e89485befb4d0072be7f9be4f">tpfAppEthCb</a>) and <a class="el" href="structtstr_eth_init_param.html">tstrEthInitParam</a> structure (which contains initialization settings for bypass mode).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__m2m__wifi.html#ga66f5bf5f84f898bdd4453f2717a3deb5" title="Synchronous API to initialize the WINC driver.">m2m_wifi_init</a> <a class="el" href="group__m2m__wifi.html#ga748dfce4572adf510387302540c84ff0" title="Synchronous API to de-initialize the WINC driver and host interface.">m2m_wifi_deinit</a> <a class="el" href="group__m2m__wifi.html#ga12005142de3d7b4aee1b7091720715fe" title="First part of m2m_wifi_init, up to the point of initializing SPI for flash access.">m2m_wifi_init_hold</a> <a class="el" href="group__m2m__wifi.html#ga1dfd77b592cbe00ce1f8576178f40ec6" title="Prepares the WINC before downloading any data (firmware, certificates, etc).">m2m_wifi_download_mode</a> <a class="el" href="structtstr_wifi_init_param.html" title="Structure, holding the Wi-fi configuration attributes such as the Wi-Fi callback ,...">tstrWifiInitParam</a> </dd></dl>

</div>
</div>
<a id="ga61307d612276cfaa10e3c5d95da59fdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61307d612276cfaa10e3c5d95da59fdf">&#9670;&nbsp;</a></span>m2m_wifi_prng_get_random_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_wifi_prng_get_random_bytes </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pu8PrngBuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>u16PrngSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronous function for retrieving from the firmware a pseudo-random set of bytes. </p>
<p>Asynchronous function for retrieving from the firmware a pseudo-random set of bytes as specified in the size passed in as a parameter. The registered Wi-Fi-cb function retrieves the random bytes through the response <a class="el" href="group___w_l_a_n_enums.html#gga57466b36df595c593e7ccc9892e14b20a63eb37ecdadeb48f9b334d7de85cbbc6">M2M_WIFI_RESP_GET_PRNG</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pu8PrngBuff</td><td>Pointer to a buffer to receive data.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">u16PrngSize</td><td>Request size in bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Size greater than the maximum specified (<a class="el" href="group___w_l_a_n_defines.html#ga6f3248a7b4183edf67a16a5cd445efea">M2M_BUFFER_MAX_SIZE</a> - sizeof(tstrPrng)) causes a negative error M2M_ERR_FAIL.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns M2M_SUCCESS for successful operations and a negative value otherwise. </dd></dl>

</div>
</div>
<a id="gae7c165141384ecd94e71c63c082b170a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7c165141384ecd94e71c63c082b170a">&#9670;&nbsp;</a></span>m2m_wifi_req_client_ctrl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_wifi_req_client_ctrl </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>u8Cmd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronous command sending function to the PS Client. </p>
<p>Asynchronous command sending function to the PS Client (a WINC board running the ps_firmware) if the PS client sends any command, it will be received through the <a class="el" href="group___w_l_a_n_enums.html#gga05ce3ed74e4bf812904f45771ef101b2a2f500dee36058b56a0ffc6ba28876337">M2M_WIFI_RESP_CLIENT_INFO</a> event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">u8Cmd</td><td>Control command sent from PS Server to PS Client (command values defined by the application)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="group__m2m__wifi.html#gac44423b48adee04e340a7acfa04e95d1">m2m_wifi_req_server_init</a> should be called first.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This mode is not supported in the current release.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__m2m__wifi.html#gac44423b48adee04e340a7acfa04e95d1" title="Synchronous function to initialize the PS Server.">m2m_wifi_req_server_init</a> <a class="el" href="group___w_l_a_n_enums.html#gga05ce3ed74e4bf812904f45771ef101b2a2f500dee36058b56a0ffc6ba28876337">M2M_WIFI_RESP_CLIENT_INFO</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns M2M_SUCCESS for successful operations and a negative value otherwise. </dd></dl>

</div>
</div>
<a id="ga1219188caab32603e96662d6bd6fd46d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1219188caab32603e96662d6bd6fd46d">&#9670;&nbsp;</a></span>m2m_wifi_req_curr_rssi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_wifi_req_curr_rssi </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronous API to request the current Receive Signal Strength (RSSI) of the current connection. </p>
<p>This function will result in the application receiving the RSSI via a <a class="el" href="group___w_l_a_n_enums.html#gga57466b36df595c593e7ccc9892e14b20ae2f28d3ff5c4356502abfc26d8f6e5f1">M2M_WIFI_RESP_CURRENT_RSSI</a> event.</p>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>A Wi-Fi notification callback of type <a class="el" href="group___w_l_a_n_callbacks.html#ga736f9be563605a41689b47de03de14d0">tpfAppWifiCb</a> MUST be implemented and registered during initialization. Registration of the callback is done through passing it to <a class="el" href="group__m2m__wifi.html#ga66f5bf5f84f898bdd4453f2717a3deb5">m2m_wifi_init</a> via the <a class="el" href="structtstr_wifi_init_param.html">tstrWifiInitParam</a> initialization structure.</li>
<li>The event <a class="el" href="group___w_l_a_n_enums.html#gga57466b36df595c593e7ccc9892e14b20ae2f28d3ff5c4356502abfc26d8f6e5f1">M2M_WIFI_RESP_CURRENT_RSSI</a> must be handled in the callback to receive the requested Rssi information.</li>
</ul>
</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns M2M_SUCCESS if the command has been successfully queued to the WINC and a negative value otherwise.</dd></dl>
<h1><a class="anchor" id="WIFIExample9"></a>
Example</h1>
<p>The code snippet demonstrates how the RSSI request is called in the application's main function and the handling of the event received in the callback.</p>
<div class="fragment"></div><!-- fragment --> 
</div>
</div>
<a id="gaecfcbf84f283cd76de00a6e884f421fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaecfcbf84f283cd76de00a6e884f421fe">&#9670;&nbsp;</a></span>m2m_wifi_req_scan_result()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_wifi_req_scan_result </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>u8Index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronous API to request the information of an access point discovered via scanning. </p>
<p>This function allows the information of any discovered access point to be retrieved. When a scan is completed, the application is informed of the number of networks (access points) discovered. Calling this function with an index, N, will return the information for the Nth access point. The information will be returned to the application via a <a class="el" href="group___w_l_a_n_enums.html#gga57466b36df595c593e7ccc9892e14b20adfb48e88c3a8e5f9dac634d62d3f53e5">M2M_WIFI_RESP_SCAN_RESULT</a> event, and the response data may be obtained through casting the pointer (pvMsg) to <a class="el" href="structtstr_m2m_wifiscan_result.html">tstrM2mWifiscanResult</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">u8Index</td><td>Index for the requested result, the index range start from 0 till number of AP's found.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns M2M_SUCCESS if the command has been successfully queued to the WINC and a negative value otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtstr_m2m_wifiscan_result.html" title="This struct contains the information corresponding to an AP in the scan result list identified by its...">tstrM2mWifiscanResult</a> <a class="el" href="group__m2m__wifi.html#ga1638306107bf997ec4df62a473dba3b4" title="Synchronous function to retrieve the number of AP&#39;s found during the last scan operation.">m2m_wifi_get_num_ap_found</a> <a class="el" href="group__m2m__wifi.html#ga39eab477f1dbb3b2a768d8a0fdc45b27" title="Asynchronous API to request the WINC to scan for networks.">m2m_wifi_request_scan</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><a class="el" href="group__m2m__wifi.html#ga39eab477f1dbb3b2a768d8a0fdc45b27">m2m_wifi_request_scan</a> must be called first to ensure up to date results are available.</li>
<li>A Wi-Fi notification callback of type <a class="el" href="group___w_l_a_n_callbacks.html#ga736f9be563605a41689b47de03de14d0">tpfAppWifiCb</a> MUST be implemented and registered in order to receive scan data after calling this function. Registration of the callback is done via the <a class="el" href="group__m2m__wifi.html#ga66f5bf5f84f898bdd4453f2717a3deb5">m2m_wifi_init</a> function.</li>
<li>The event <a class="el" href="group___w_l_a_n_enums.html#gga57466b36df595c593e7ccc9892e14b20adfb48e88c3a8e5f9dac634d62d3f53e5">M2M_WIFI_RESP_SCAN_RESULT</a> must be handled in the callback to receive the requested scan information.</li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd><ul>
<li>This API is valid only for STA mode, it may be called regardless of the connection state (connected or disconnected).</li>
<li>Calling this function without first issuing a scan request may lead to stale data being recovered.</li>
<li>Application code should refrain from introducing significant delays between issuing the scan request and scan result requests.</li>
</ul>
</dd></dl>
<h1><a class="anchor" id="WIFIExample8"></a>
Example</h1>
<p>The code snippet demonstrates an example of how the scan request is called from the application's main function and the handling of the events received in the response.</p>
<div class="fragment"></div><!-- fragment --> 
</div>
</div>
<a id="gac44423b48adee04e340a7acfa04e95d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac44423b48adee04e340a7acfa04e95d1">&#9670;&nbsp;</a></span>m2m_wifi_req_server_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_wifi_req_server_init </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>u8Ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronous function to initialize the PS Server. </p>
<p>The WINC supports non secure communication with another WINC, (SERVER/CLIENT) through one byte command (probe request and probe response) without any connection setup. The server mode can't be used with any other modes (STA/AP)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">u8Ch</td><td>Server listening channel</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__m2m__wifi.html#gae7c165141384ecd94e71c63c082b170a" title="Asynchronous command sending function to the PS Client.">m2m_wifi_req_client_ctrl</a></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This mode is not supported in the current release.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns M2M_SUCCESS for successful operations and a negative value otherwise. </dd></dl>

</div>
</div>
<a id="ga39eab477f1dbb3b2a768d8a0fdc45b27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39eab477f1dbb3b2a768d8a0fdc45b27">&#9670;&nbsp;</a></span>m2m_wifi_request_scan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_wifi_request_scan </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>u8Ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronous API to request the WINC to scan for networks. </p>
<p>Scan statuses are delivered to the application via the Wi-Fi event callback (<a class="el" href="group___w_l_a_n_callbacks.html#ga736f9be563605a41689b47de03de14d0">tpfAppWifiCb</a>) in three stages. The first step involves the event <a class="el" href="group___w_l_a_n_enums.html#gga57466b36df595c593e7ccc9892e14b20ad835febbe18b7e3cc6ce4693951354fe">M2M_WIFI_RESP_SCAN_DONE</a> which, if successful, provides the number of detected networks (access points). The application must then read the list of access points via multiple calls to the asynchronous <a class="el" href="group__m2m__wifi.html#gaecfcbf84f283cd76de00a6e884f421fe">m2m_wifi_req_scan_result</a> API. For each call to this function, the application will receive (step three) the event <a class="el" href="group___w_l_a_n_enums.html#gga57466b36df595c593e7ccc9892e14b20adfb48e88c3a8e5f9dac634d62d3f53e5">M2M_WIFI_RESP_SCAN_RESULT</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">u8Ch</td><td>RF Channel ID for SCAN operation. It should be set according to <a class="el" href="group___w_l_a_n_enums.html#ga2a91dd671e2672dba1a7ed45230f3a99">tenuM2mScanCh</a>, with a value of M2M_WIFI_CH_ALL to scan all channels.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns M2M_SUCCESS if the command has been successfully queued to the WINC and a negative value otherwise.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>A Wi-Fi notification callback of type <a class="el" href="group___w_l_a_n_callbacks.html#ga736f9be563605a41689b47de03de14d0">tpfAppWifiCb</a> MUST be implemented and registered at initialization. Registration of the callback is done via <a class="el" href="group__m2m__wifi.html#ga66f5bf5f84f898bdd4453f2717a3deb5">m2m_wifi_init</a>.</li>
<li>The events <a class="el" href="group___w_l_a_n_enums.html#gga57466b36df595c593e7ccc9892e14b20ad835febbe18b7e3cc6ce4693951354fe">M2M_WIFI_RESP_SCAN_DONE</a> and <a class="el" href="group___w_l_a_n_enums.html#gga57466b36df595c593e7ccc9892e14b20adfb48e88c3a8e5f9dac634d62d3f53e5">M2M_WIFI_RESP_SCAN_RESULT</a> must be handled in the (<a class="el" href="group___w_l_a_n_callbacks.html#ga736f9be563605a41689b47de03de14d0">tpfAppWifiCb</a>) callback.</li>
<li>The <a class="el" href="group__m2m__wifi.html#gae397199d8523f172b33309b82c34c2af">m2m_wifi_handle_events</a> function MUST be called to receive the responses in the callback.</li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This API is valid only for STA mode, it may be called regardless of connection state (connected or disconnected states).</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___w_l_a_n_enums.html#gga57466b36df595c593e7ccc9892e14b20ad835febbe18b7e3cc6ce4693951354fe">M2M_WIFI_RESP_SCAN_DONE</a> <a class="el" href="group___w_l_a_n_enums.html#gga57466b36df595c593e7ccc9892e14b20adfb48e88c3a8e5f9dac634d62d3f53e5">M2M_WIFI_RESP_SCAN_RESULT</a> <a class="el" href="group___w_l_a_n_callbacks.html#ga736f9be563605a41689b47de03de14d0" title="This is the main callback function for the Wi-Fi driver and is responsible for processing any M2M_WIF...">tpfAppWifiCb</a> <a class="el" href="structtstr_m2m_wifiscan_result.html" title="This struct contains the information corresponding to an AP in the scan result list identified by its...">tstrM2mWifiscanResult</a> <a class="el" href="group___w_l_a_n_enums.html#ga2a91dd671e2672dba1a7ed45230f3a99" title="This enum contains all the Wi-Fi RF channels.">tenuM2mScanCh</a> <a class="el" href="group__m2m__wifi.html#ga66f5bf5f84f898bdd4453f2717a3deb5" title="Synchronous API to initialize the WINC driver.">m2m_wifi_init</a> <a class="el" href="group__m2m__wifi.html#gae397199d8523f172b33309b82c34c2af" title="Synchronous M2M event handler function.">m2m_wifi_handle_events</a> <a class="el" href="group__m2m__wifi.html#gaecfcbf84f283cd76de00a6e884f421fe" title="Asynchronous API to request the information of an access point discovered via scanning.">m2m_wifi_req_scan_result</a></dd></dl>
<h1><a class="anchor" id="WIFIExample6"></a>
Example</h1>
<p>The code snippet demonstrates an example of how the scan request is called from the application's main function and the handling of the events received in response.</p>
<div class="fragment"></div><!-- fragment --> 
</div>
</div>
<a id="ga7835becaa9fcc09485724904d06ef182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7835becaa9fcc09485724904d06ef182">&#9670;&nbsp;</a></span>m2m_wifi_request_scan_passive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_wifi_request_scan_passive </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>u8Ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>u16ScanTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to <a class="el" href="group__m2m__wifi.html#ga39eab477f1dbb3b2a768d8a0fdc45b27">m2m_wifi_request_scan</a> but performs passive scanning instead of active scanning. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">u8Ch</td><td>RF Channel ID for SCAN operation. It should be set according to <a class="el" href="group___w_l_a_n_enums.html#ga2a91dd671e2672dba1a7ed45230f3a99">tenuM2mScanCh</a>. With a value of M2M_WIFI_CH_ALL, means to scan all channels.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">u16ScanTime</td><td>The time in ms that passive scan is listening for beacons on each channel per one slot, enter 0 for default setting.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is not allowed in AP mode. It works only for STA mode (both connected or disconnected states).</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>A Wi-Fi notification callback of type <a class="el" href="group___w_l_a_n_callbacks.html#ga736f9be563605a41689b47de03de14d0">tpfAppWifiCb</a> MUST be implemented and registered at initialization. Registering the callback is done through passing it to the <a class="el" href="group__m2m__wifi.html#ga66f5bf5f84f898bdd4453f2717a3deb5">m2m_wifi_init</a>.</li>
<li>The events <a class="el" href="group___w_l_a_n_enums.html#gga57466b36df595c593e7ccc9892e14b20ad835febbe18b7e3cc6ce4693951354fe">M2M_WIFI_RESP_SCAN_DONE</a> and <a class="el" href="group___w_l_a_n_enums.html#gga57466b36df595c593e7ccc9892e14b20adfb48e88c3a8e5f9dac634d62d3f53e5">M2M_WIFI_RESP_SCAN_RESULT</a>. must be handled in the callback.</li>
<li>The <a class="el" href="group__m2m__wifi.html#gae397199d8523f172b33309b82c34c2af">m2m_wifi_handle_events</a> function MUST be called to receive the responses in the callback.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___w_l_a_n_enums.html#gga57466b36df595c593e7ccc9892e14b20ad835febbe18b7e3cc6ce4693951354fe">M2M_WIFI_RESP_SCAN_DONE</a> <a class="el" href="group___w_l_a_n_enums.html#gga57466b36df595c593e7ccc9892e14b20adfb48e88c3a8e5f9dac634d62d3f53e5">M2M_WIFI_RESP_SCAN_RESULT</a> <a class="el" href="group___w_l_a_n_callbacks.html#ga736f9be563605a41689b47de03de14d0" title="This is the main callback function for the Wi-Fi driver and is responsible for processing any M2M_WIF...">tpfAppWifiCb</a> <a class="el" href="structtstr_m2_m_scan_option.html" title="This struct contains the configuration options for Wi-Fi scan.">tstrM2MScanOption</a> <a class="el" href="structtstr_m2m_wifiscan_result.html" title="This struct contains the information corresponding to an AP in the scan result list identified by its...">tstrM2mWifiscanResult</a> <a class="el" href="group___w_l_a_n_enums.html#ga2a91dd671e2672dba1a7ed45230f3a99" title="This enum contains all the Wi-Fi RF channels.">tenuM2mScanCh</a> <a class="el" href="group__m2m__wifi.html#ga66f5bf5f84f898bdd4453f2717a3deb5" title="Synchronous API to initialize the WINC driver.">m2m_wifi_init</a> <a class="el" href="group__m2m__wifi.html#ga39eab477f1dbb3b2a768d8a0fdc45b27" title="Asynchronous API to request the WINC to scan for networks.">m2m_wifi_request_scan</a> <a class="el" href="group__m2m__wifi.html#gae397199d8523f172b33309b82c34c2af" title="Synchronous M2M event handler function.">m2m_wifi_handle_events</a> <a class="el" href="group__m2m__wifi.html#gaecfcbf84f283cd76de00a6e884f421fe" title="Asynchronous API to request the information of an access point discovered via scanning.">m2m_wifi_req_scan_result</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns M2M_SUCCESS for successful operations and a negative value otherwise. </dd></dl>

</div>
</div>
<a id="ga113c7905d21a932de8c06f0af023c428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga113c7905d21a932de8c06f0af023c428">&#9670;&nbsp;</a></span>m2m_wifi_request_scan_ssid_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_wifi_request_scan_ssid_list </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>u8Ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pu8Ssidlist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronous Wi-Fi scan request on the given channel and the hidden scan list. </p>
<p>The scan status is delivered in the Wi-Fi event callback and then the application is to read the scan results sequentially. The number of APs found (N) is returned in event <a class="el" href="group___w_l_a_n_enums.html#gga57466b36df595c593e7ccc9892e14b20ad835febbe18b7e3cc6ce4693951354fe">M2M_WIFI_RESP_SCAN_DONE</a> with the number of found APs. The application could read the list of APs by calling the function <a class="el" href="group__m2m__wifi.html#gaecfcbf84f283cd76de00a6e884f421fe">m2m_wifi_req_scan_result</a> N times.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">u8Ch</td><td>RF Channel ID for SCAN operation. It should be set according to <a class="el" href="group___w_l_a_n_enums.html#ga2a91dd671e2672dba1a7ed45230f3a99">tenuM2mScanCh</a>. With a value of M2M_WIFI_CH_ALL, means to scan all channels.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pu8Ssidlist</td><td>u8SsidList is a buffer containing a list of hidden SSIDs to include during the scan. The first byte in the buffer, u8SsidList[0], is the number of SSIDs encoded in the string. The number of hidden SSIDs cannot exceed <a class="el" href="group___w_l_a_n_defines.html#gaeace85ae13a66b042b2b3d044460138d">MAX_HIDDEN_SITES</a>. All SSIDs are concatenated in the following bytes and each SSID is prefixed with a one-byte header containing its length. The total number of bytes in u8SsidList buffer, including length byte, cannot exceed 133 bytes (MAX_HIDDEN_SITES SSIDs x 32 bytes each, which is max SSID length). For instance, encoding the two hidden SSIDs "DEMO_AP" and "TEST" results in the following buffer content:</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line">uint8_t u8SsidList[14];</div>
<div class="line">u8SsidList[0] = 2; <span class="comment">// Number of SSIDs is 2</span></div>
<div class="line">u8SsidList[1] = 7; <span class="comment">// Length of the string &quot;DEMO_AP&quot; without NULL termination</span></div>
<div class="line">memcpy(&amp;u8SsidList[2], <span class="stringliteral">&quot;DEMO_AP&quot;</span>, 7);  <span class="comment">// Bytes index 2-9 containing the string DEMO_AP</span></div>
<div class="line">u8SsidList[9] = 4; <span class="comment">// Length of the string &quot;TEST&quot; without NULL termination</span></div>
<div class="line">memcpy(&amp;u8SsidList[10], <span class="stringliteral">&quot;TEST&quot;</span>, 4);  <span class="comment">// Bytes index 10-13 containing the string TEST</span></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>It works with STA/AP mode (connected or disconnected).</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>A Wi-Fi notification callback of type <a class="el" href="group___w_l_a_n_callbacks.html#ga736f9be563605a41689b47de03de14d0">tpfAppWifiCb</a> MUST be implemented and registered at initialization. Registering the callback is done through passing it to the <a class="el" href="group__m2m__wifi.html#ga66f5bf5f84f898bdd4453f2717a3deb5">m2m_wifi_init</a>.</li>
<li>The events <a class="el" href="group___w_l_a_n_enums.html#gga57466b36df595c593e7ccc9892e14b20ad835febbe18b7e3cc6ce4693951354fe">M2M_WIFI_RESP_SCAN_DONE</a> and <a class="el" href="group___w_l_a_n_enums.html#gga57466b36df595c593e7ccc9892e14b20adfb48e88c3a8e5f9dac634d62d3f53e5">M2M_WIFI_RESP_SCAN_RESULT</a>. must be handled in the callback.</li>
<li>The <a class="el" href="group__m2m__wifi.html#gae397199d8523f172b33309b82c34c2af">m2m_wifi_handle_events</a> function MUST be called to receive the responses in the callback.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___w_l_a_n_enums.html#gga57466b36df595c593e7ccc9892e14b20ad835febbe18b7e3cc6ce4693951354fe">M2M_WIFI_RESP_SCAN_DONE</a> <a class="el" href="group___w_l_a_n_enums.html#gga57466b36df595c593e7ccc9892e14b20adfb48e88c3a8e5f9dac634d62d3f53e5">M2M_WIFI_RESP_SCAN_RESULT</a> <a class="el" href="group___w_l_a_n_callbacks.html#ga736f9be563605a41689b47de03de14d0" title="This is the main callback function for the Wi-Fi driver and is responsible for processing any M2M_WIF...">tpfAppWifiCb</a> <a class="el" href="structtstr_m2m_wifiscan_result.html" title="This struct contains the information corresponding to an AP in the scan result list identified by its...">tstrM2mWifiscanResult</a> <a class="el" href="group___w_l_a_n_enums.html#ga2a91dd671e2672dba1a7ed45230f3a99" title="This enum contains all the Wi-Fi RF channels.">tenuM2mScanCh</a> <a class="el" href="group__m2m__wifi.html#ga66f5bf5f84f898bdd4453f2717a3deb5" title="Synchronous API to initialize the WINC driver.">m2m_wifi_init</a> <a class="el" href="group__m2m__wifi.html#gae397199d8523f172b33309b82c34c2af" title="Synchronous M2M event handler function.">m2m_wifi_handle_events</a> <a class="el" href="group__m2m__wifi.html#gaecfcbf84f283cd76de00a6e884f421fe" title="Asynchronous API to request the information of an access point discovered via scanning.">m2m_wifi_req_scan_result</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns M2M_SUCCESS for successful operations and a negative value otherwise.</dd></dl>
<h1><a class="anchor" id="WIFIExample6b"></a>
Example</h1>
<p>The code snippet demonstrates an example of how the scan request is called from the application's main function and the handling of the events received in response.</p>
<div class="fragment"></div><!-- fragment --> 
</div>
</div>
<a id="gae074746e383410f327d0fd56dc46b848"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae074746e383410f327d0fd56dc46b848">&#9670;&nbsp;</a></span>m2m_wifi_request_sleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_wifi_request_sleep </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>u32SlpReqTime</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronous API to place the WINC into sleep mode for a specified period of time. </p>
<p>Power-save sleep request function, which requests the WINC device to sleep in the currently configured power save mode, as set using <a class="el" href="group__m2m__wifi.html#ga38ba065f25bf5cc2bbd35d6498121192">m2m_wifi_set_sleep_mode</a>, for a specific time as defined by the parameter u32SlpReqTime (measured in milliseconds). This function should be used when the WINC is running in <a class="el" href="group___w_l_a_n_enums.html#ggae6bd0ac78bfca4cda17d9dbedf79ad7ea00718741cee171209780cd7266878f84">M2M_PS_MANUAL</a> power save mode only. A wake up request is automatically performed by the WINC device when any host driver API function, e.g. Wi-Fi or socket operation is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">u32SlpReqTime</td><td>Request sleep time in ms.<br  />
 The best recommended sleep duration is left to be determined by the application. Taking into account that if the application sends notifications very rarely, sleeping for a long time can be a power-efficient decision. In contrast, applications that are sensitive for long periods of absence can experience performance degradation in the connection if long sleeping times are used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns M2M_SUCCESS for successful operation and a negative value otherwise.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The function should be called in <a class="el" href="group___w_l_a_n_enums.html#ggae6bd0ac78bfca4cda17d9dbedf79ad7ea00718741cee171209780cd7266878f84">M2M_PS_MANUAL</a> power save mode only. As enumerated in <a class="el" href="group___w_l_a_n_enums.html#gae6bd0ac78bfca4cda17d9dbedf79ad7e">tenuPowerSaveModes</a>. It's also important to note that during the sleeping time while in the M2M_PS_MANUAL mode, AP beacon monitoring is bypassed and the Wi-Fi-connection may drop if the sleep period is elongated.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___w_l_a_n_enums.html#gae6bd0ac78bfca4cda17d9dbedf79ad7e" title="This enum contains all the supported Wi-Fi Power Save modes.">tenuPowerSaveModes</a> <a class="el" href="group__m2m__wifi.html#ga38ba065f25bf5cc2bbd35d6498121192" title="Synchronous API to set the power-save mode of the WINC.">m2m_wifi_set_sleep_mode</a> </dd></dl>

</div>
</div>
<a id="ga7667a375fd3c9ffa26566507b256f0c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7667a375fd3c9ffa26566507b256f0c1">&#9670;&nbsp;</a></span>m2m_wifi_send_crl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_wifi_send_crl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtstr_tls_crl_info.html">tstrTlsCrlInfo</a> *&#160;</td>
          <td class="paramname"><em>pCRL</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronous API that notifies the WINC with the Certificate Revocation List. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pCRL</td><td>Pointer to the structure containing certificate revocation list details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns M2M_SUCCESS if the command has been successfully queued to the WINC and a negative value otherwise. </dd></dl>

</div>
</div>
<a id="ga5d817bd436735409766faca4021c06c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d817bd436735409766faca4021c06c9">&#9670;&nbsp;</a></span>m2m_wifi_send_ethernet_pkt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_wifi_send_ethernet_pkt </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pu8Packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>u16PacketSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronous API to queue an Ethernet packet for transmission by the WINC. </p>
<p>Transmit a packet directly in ETHERNET/bypass mode where the TCP/IP stack is disabled and the implementation of this packet is left to the application developer. The Ethernet packet composition is left to the application developer.</p>
<dl class="section note"><dt>Note</dt><dd>Packets are the user's responsibility.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function available in ETHERNET/Bypass mode ONLY. Make sure that application defines ETH_MODE.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pu8Packet</td><td>Pointer to a buffer holding the whole Ethernet frame.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">u16PacketSize</td><td>The size of the whole packet in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns M2M_SUCCESS if the command has been successfully queued to the WINC and a negative value otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>m2m_wifi_enable_mac_mcast m2m_wifi_set_receive_buffer </dd></dl>

</div>
</div>
<a id="ga36ac9f33e8c7208e9ec6fd1a2b02f549"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36ac9f33e8c7208e9ec6fd1a2b02f549">&#9670;&nbsp;</a></span>m2m_wifi_set_battery_voltage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_wifi_set_battery_voltage </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>u16BattVoltx100</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the battery voltage to update the firmware calculations. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Must be called after initialization through the following function <a class="el" href="group__m2m__wifi.html#ga66f5bf5f84f898bdd4453f2717a3deb5">m2m_wifi_init</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">u16BattVoltx100</td><td>Battery Voltage as double.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns M2M_SUCCESS for success and a negative value otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__m2m__wifi.html#ga66f5bf5f84f898bdd4453f2717a3deb5" title="Synchronous API to initialize the WINC driver.">m2m_wifi_init</a> </dd></dl>

</div>
</div>
<a id="gab40418aa14adc8ee037b1089ffb6449c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab40418aa14adc8ee037b1089ffb6449c">&#9670;&nbsp;</a></span>m2m_wifi_set_cust_InfoElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_wifi_set_cust_InfoElement </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pau8M2mCustInfoElement</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronous API to add or remove a user-defined Information Element. </p>
<p>This function allows the application to provide a custom Information Element to the WINC that will be included in all beacon and probe response frames, while in Access Point mode. If it is required to delete these IEs, fill the buffer with zeros.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pau8M2mCustInfoElement</td><td>Pointer to Buffer containing the IE to be used. It is the application developer's responsibility to ensure on the correctness of the information element's ordering passed in. If the pointer is null, this removes any current custom IE. If non-null, the pointer must reference data in the following format:</td></tr>
  </table>
  </dd>
</dl>
<pre class="fragment">    --------------- ---------- ---------- ------------------- -------- -------- ----------- -----------------------
    | Byte[0]       | Byte[1]  | Byte[2]  | Byte[3:length1+2] | ..... | Byte[n] | Byte[n+1] | Byte[n+2:lengthx+2] |
    |---------------|----------|----------|-------------------|-------- --------|-----------|---------------------|
    | #of all Bytes | IE1 ID   | Length1  | Data1(Hex Coded)  | ..... | IEx ID  | Lengthx   | Datax(Hex Coded)    |
    --------------- ---------- ---------- ------------------- -------- -------- ----------- -----------------------
</pre><dl class="section warning"><dt>Warning</dt><dd>Size of All elements combined must not exceed 255 byte. Used in Access Point Mode.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>IEs Format will follow the above format.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns M2M_SUCCESS if the command has been successfully queued to the WINC and a negative value otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__m2m__wifi.html#ga97cd0378aa47bc3039ab0e30c926155a" title="Asynchronous API to enable or disable the native Simple Network Time Protocol(SNTP) client running on...">m2m_wifi_enable_sntp</a></dd></dl>
<h1><a class="anchor" id="WIFIExample11"></a>
Example</h1>
<p>The example demonstrates how the information elements are set using this function.</p>
<div class="fragment"></div><!-- fragment --> 
</div>
</div>
<a id="ga6298406d05df2a867a2c0f6fe412c563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6298406d05df2a867a2c0f6fe412c563">&#9670;&nbsp;</a></span>m2m_wifi_set_device_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_wifi_set_device_name </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pu8DeviceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>u8DeviceNameLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronous API to set the Wi-Fi Direct "Device Name" of the WINC. </p>
<p>Sets the WINC device name. The name string is used as a device name in DHCP hostname (option 12). If a device is not set through this function a default name is assigned. The default name is WINC-XX-YY, where XX and YY are the last 2 octets of the OTP MAC address. If OTP (eFuse) is programmed, then the default name is WINC-00-00.</p>
<dl class="section warning"><dt>Warning</dt><dd>The function called once after initialization.<br  />
 Used for DHCP client hostname option (12).<br  />
 Device name shall contain only characters allowed in valid internet host name as defined in RFC 952 and 1123.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pu8DeviceName</td><td>Buffer holding the device name. Device name is a null terminated C string.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">u8DeviceNameLength</td><td>Length of the device name. Should not exceed the maximum device name's length <a class="el" href="group___w_l_a_n_defines.html#ga13694b7fb6c7afefab58c38a43aa1957">M2M_DEVICE_NAME_MAX</a> (including null character).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns M2M_SUCCESS if the command has been successfully queued to the WINC and a negative value otherwise. </dd></dl>

</div>
</div>
<a id="ga73ecacb3650558efb9a437443b0deaf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73ecacb3650558efb9a437443b0deaf5">&#9670;&nbsp;</a></span>m2m_wifi_set_gain_table_idx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_wifi_set_gain_table_idx </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>u8GainTableIdx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the Gain table index corresponding to specific WiFi region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">u8GainTableIdx</td><td>Change the gain table index based on the WiFi region it is suppose to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Must be called after the initialization and before any connection request. The corresponding gain tables must be present in the flash.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns M2M_SUCCESS for successful operations and a negative value otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__m2m__wifi.html#ga66f5bf5f84f898bdd4453f2717a3deb5" title="Synchronous API to initialize the WINC driver.">m2m_wifi_init</a> </dd></dl>

</div>
</div>
<a id="ga30347bdddc5fc20ebe28e7e40a1b847d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30347bdddc5fc20ebe28e7e40a1b847d">&#9670;&nbsp;</a></span>m2m_wifi_set_gains()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_wifi_set_gains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtstr_m2m_wifi_gains_params.html">tstrM2mWifiGainsParams</a> *&#160;</td>
          <td class="paramname"><em>pstrM2mGain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the chip PPA gain for 11b/11gn. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pstrM2mGain</td><td><a class="el" href="structtstr_m2m_wifi_gains_params.html">tstrM2mWifiGainsParams</a> contain gain parameters as implemented in rf document.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Must be called after initialization through the following function <a class="el" href="group__m2m__wifi.html#ga66f5bf5f84f898bdd4453f2717a3deb5">m2m_wifi_init</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns M2M_SUCCESS if the command has been successfully queued to the WINC and a negative value otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__m2m__wifi.html#ga66f5bf5f84f898bdd4453f2717a3deb5" title="Synchronous API to initialize the WINC driver.">m2m_wifi_init</a> </dd></dl>

</div>
</div>
<a id="gaa19969f83ad50c28d9bea07b2f4f0280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa19969f83ad50c28d9bea07b2f4f0280">&#9670;&nbsp;</a></span>m2m_wifi_set_lsn_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_wifi_set_lsn_int </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtstr_m2m_lsn_int.html">tstrM2mLsnInt</a> *&#160;</td>
          <td class="paramname"><em>pstrM2mLsnInt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronous API to set Wi-Fi listen interval for power save operation. </p>
<p>This is one of the two synchronous power-save setting functions that allow the host MCU application to tweak the system power consumption. Such tweaking can be done by modifying the Wi-Fi listen interval. The listen interval is how many beacon periods the station can sleep before it wakes up to receive data buffered in the AP. It is represented in units of AP beacon periods(100ms).</p>
<dl class="section warning"><dt>Warning</dt><dd>The function should be called once after initialization.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pstrM2mLsnInt</td><td>Structure holding the listen interval configuration.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The function <a class="el" href="group__m2m__wifi.html#ga38ba065f25bf5cc2bbd35d6498121192">m2m_wifi_set_sleep_mode</a> shall be called first, to set the power saving mode required.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns M2M_SUCCESS if the command has been successfully queued to the WINC and a negative value otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtstr_m2m_lsn_int.html" title="This struct contains the Listen Interval. It is the value of the Wi-Fi STA Listen Interval when power...">tstrM2mLsnInt</a> <a class="el" href="group__m2m__wifi.html#ga38ba065f25bf5cc2bbd35d6498121192" title="Synchronous API to set the power-save mode of the WINC.">m2m_wifi_set_sleep_mode</a> </dd></dl>

</div>
</div>
<a id="ga6cc2b80205ac21bd62102b24927788df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6cc2b80205ac21bd62102b24927788df">&#9670;&nbsp;</a></span>m2m_wifi_set_mac_address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_wifi_set_mac_address </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>au8MacAddress</em>[6]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronous API for assigning a MAC address to the WINC. </p>
<p>This function is intended to allow non-production software to assign a MAC address to the WINC.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function is intended for development use only and not for use in production software.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">au8MacAddress</td><td>MAC Address to be provisioned to the WINC.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns M2M_SUCCESS if the command has been successfully queued to the WINC and a negative value otherwise. </dd></dl>

</div>
</div>
<a id="gad13438fd7ceb428310eb6abe9ba42fef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad13438fd7ceb428310eb6abe9ba42fef">&#9670;&nbsp;</a></span>m2m_wifi_set_power_profile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_wifi_set_power_profile </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>u8PwrMode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the power profile mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">u8PwrMode</td><td>Change the WINC power profile to different mode based on the enumeration <a class="el" href="group___w_l_a_n_enums.html#ga8ebb42d50f077fca156f84dfd0c7a167">tenuM2mPwrMode</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>May only be called after initialization, before any connection request, and may not be used to change the power mode thereafter.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns M2M_SUCCESS for success and a negative value otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___w_l_a_n_enums.html#ga8ebb42d50f077fca156f84dfd0c7a167">tenuM2mPwrMode</a> <a class="el" href="group__m2m__wifi.html#ga66f5bf5f84f898bdd4453f2717a3deb5" title="Synchronous API to initialize the WINC driver.">m2m_wifi_init</a> </dd></dl>

</div>
</div>
<a id="gaf270d6f64b704d8a13358ddf4c7f21a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf270d6f64b704d8a13358ddf4c7f21a9">&#9670;&nbsp;</a></span>m2m_wifi_set_scan_options()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_wifi_set_scan_options </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtstr_m2_m_scan_option.html">tstrM2MScanOption</a> *&#160;</td>
          <td class="paramname"><em>ptstrM2MScanOption</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronous API for configuring the behaviour of the WINC network scanning functions. </p>
<p>This function allows the application to tune the scanning behaviour of the WINC using the parameters described in <a class="el" href="structtstr_m2_m_scan_option.html">tstrM2MScanOption</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptstrM2MScanOption;</td><td>Pointer to the structure holding the Scan Parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns M2M_SUCCESS if the command has been successfully queued to the WINC and a negative value otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___w_l_a_n_enums.html#ga2a91dd671e2672dba1a7ed45230f3a99" title="This enum contains all the Wi-Fi RF channels.">tenuM2mScanCh</a> <a class="el" href="group__m2m__wifi.html#ga39eab477f1dbb3b2a768d8a0fdc45b27" title="Asynchronous API to request the WINC to scan for networks.">m2m_wifi_request_scan</a> <a class="el" href="structtstr_m2_m_scan_option.html" title="This struct contains the configuration options for Wi-Fi scan.">tstrM2MScanOption</a> </dd></dl>

</div>
</div>
<a id="ga0f7cd8414e3725cae803b89c09b41bff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f7cd8414e3725cae803b89c09b41bff">&#9670;&nbsp;</a></span>m2m_wifi_set_scan_region()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_wifi_set_scan_region </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>u16ScanRegion</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronous API for configuring the regulatory restrictions that may affect the WINC scanning behaviour. </p>
<p>This function sets a property called the scan region, a parameter that affects the range of channels that the WINC may legally scan given a geographic region.</p>
<p>For 2.4GHz, supported in the current release, the requested scan region cannot exceed the maximum number of channels (14).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">u16ScanRegion</td><td><a class="el" href="group___w_l_a_n_enums.html#gga7ffc49398ba597866801fd1e847a4183a32a37613e77fb416d0995b8612262bea">ASIA</a> <a class="el" href="group___w_l_a_n_enums.html#gga7ffc49398ba597866801fd1e847a4183a66b9054cf247c2d2a24ac27d7ae6eb72">EUROPE</a> <a class="el" href="group___w_l_a_n_enums.html#gga7ffc49398ba597866801fd1e847a4183a6a118305aab2bd0ff82e4d51f1898753">NORTH_AMERICA</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns M2M_SUCCESS if the command has been successfully queued to the WINC and a negative value otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___w_l_a_n_enums.html#ga7ffc49398ba597866801fd1e847a4183" title="This enum contains all the Wi-Fi channel regions.">tenuM2mScanRegion</a> <a class="el" href="group__m2m__wifi.html#ga39eab477f1dbb3b2a768d8a0fdc45b27" title="Asynchronous API to request the WINC to scan for networks.">m2m_wifi_request_scan</a> </dd></dl>

</div>
</div>
<a id="ga38ba065f25bf5cc2bbd35d6498121192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38ba065f25bf5cc2bbd35d6498121192">&#9670;&nbsp;</a></span>m2m_wifi_set_sleep_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_wifi_set_sleep_mode </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>u8PsTyp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>u8BcastEn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronous API to set the power-save mode of the WINC. </p>
<p>This is one of the two synchronous power-save setting functions that allow the host MCU application to tweak the system power consumption. Such tweaking can be done through one of two ways:</p><ul>
<li>1) Changing the power save mode, to one of the allowed power save modes (see <a class="el" href="group___w_l_a_n_enums.html#gae6bd0ac78bfca4cda17d9dbedf79ad7e">tenuPowerSaveModes</a>). This is done by setting the first parameter.</li>
<li>2) Configuring DTIM monitoring: Configuring beacon monitoring parameters by enabling or disabling the reception of broadcast/multicast data. This is done by setting the second parameter.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">u8PsTyp</td><td>Desired power saving mode. Supported types are enumerated in <a class="el" href="group___w_l_a_n_enums.html#gae6bd0ac78bfca4cda17d9dbedf79ad7e">tenuPowerSaveModes</a>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">u8BcastEn</td><td>Broadcast reception enable flag. If set to 1, the WINC will wake for each DTIM beacon to ensure broadcast traffic can be received. If set to 0, the WINC will not wakeup at the DTIM beacon, ignoring broadcast traffic, instead it will wake every N beacon periods, as per the negotiated Listen Interval.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The function called once after initialization.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns M2M_SUCCESS for successful operation and a negative value otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___w_l_a_n_enums.html#gae6bd0ac78bfca4cda17d9dbedf79ad7e" title="This enum contains all the supported Wi-Fi Power Save modes.">tenuPowerSaveModes</a> <a class="el" href="group__m2m__wifi.html#gac53a9e3e4cd24b318e4e3722c5afb4ed" title="Synchronous API to retrieve the current power save mode of the WINC.">m2m_wifi_get_sleep_mode</a> <a class="el" href="group__m2m__wifi.html#gaa19969f83ad50c28d9bea07b2f4f0280" title="Asynchronous API to set Wi-Fi listen interval for power save operation.">m2m_wifi_set_lsn_int</a> </dd></dl>

</div>
</div>
<a id="ga6c4c223a4eb484298c3742d40eb3c2f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c4c223a4eb484298c3742d40eb3c2f7">&#9670;&nbsp;</a></span>m2m_wifi_set_static_ip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_wifi_set_static_ip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtstr_m2_m_i_p_config.html">tstrM2MIPConfig</a> *&#160;</td>
          <td class="paramname"><em>pstrStaticIPConf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronous API to manually assign a (static) IP address to the WINC. </p>
<p>Assigns a static IP address to the WINC. Typically an infrastructure access point will be able to provide an IP address to all clients after they associate. The WINC will request configuration via DHCP automatically after successfully connecting to an access point. This function should only be called in the event that the network has no DHCP server or in case the application wants to assign a predefined known IP address and the application. This function can be used to assign a static IP address in case the application knows the specifics of the network. The user must keep in mind that assigning a static IP address might result in an IP address conflict. In case of an IP address conflict observed by the WINC the user will get a response of <a class="el" href="group___w_l_a_n_enums.html#gga064de09dec1d5e88ed8d075fa40f57deadeac372bffcc8d8f4db24d4bd0ecdde5">M2M_WIFI_RESP_IP_CONFLICT</a> in the Wi-Fi callback. The application is then responsible to either solve the conflict or assign another IP address.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The application must first call <a class="el" href="group__m2m__wifi.html#gaee8e0e7b992d84bd0762dfbb48e6aaf7">m2m_wifi_enable_dhcp</a> to request that DHCP functionality is disabled prior to calling this function.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Exercise caution using this function. DHCP is the preferred method for configuring IP addresses.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pstrStaticIPConf</td><td>Pointer to a structure holding the static IP configuration (IP, Gateway, subnet mask and DNS address).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns M2M_SUCCESS if the command has been successfully queued to the WINC and a negative value otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtstr_m2_m_i_p_config.html" title="This struct contains the static IP configuration.">tstrM2MIPConfig</a> </dd></dl>

</div>
</div>
<a id="ga4055ecd51b8c38e427d9f418f1743712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4055ecd51b8c38e427d9f418f1743712">&#9670;&nbsp;</a></span>m2m_wifi_set_system_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_wifi_set_system_time </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>u32UTCSeconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronous function for setting the system time within the WINC. </p>
<p>Function for setting the system time in time/date format (uint32_t). The <a class="el" href="structtstr_system_time.html">tstrSystemTime</a> structure can be used as a reference to the time values that should be set and pass its value as uint32_t.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">u32UTCSeconds</td><td>Seconds elapsed since January 1, 1900 (NTP Timestamp).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns M2M_SUCCESS if the command has been successfully queued to the WINC and a negative value otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__m2m__wifi.html#ga97cd0378aa47bc3039ab0e30c926155a" title="Asynchronous API to enable or disable the native Simple Network Time Protocol(SNTP) client running on...">m2m_wifi_enable_sntp</a> <a class="el" href="structtstr_system_time.html" title="This struct contains the system time.">tstrSystemTime</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>If there is an RTC on the host MCU, the SNTP may be disabled and the host may set the system time within the firmware using the API <a class="el" href="group__m2m__wifi.html#ga4055ecd51b8c38e427d9f418f1743712">m2m_wifi_set_system_time</a>. </dd></dl>

</div>
</div>
<a id="gadde88bb1e426f92e38c99fb32d96293d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadde88bb1e426f92e38c99fb32d96293d">&#9670;&nbsp;</a></span>m2m_wifi_set_tx_power()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_wifi_set_tx_power </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>u8TxPwrLevel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the TX power tenuM2mTxPwrLevel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">u8TxPwrLevel</td><td>Change the TX power based on the enumeration <a class="el" href="group___w_l_a_n_enums.html#gac76a1f79185dcf95e7f0e82ba0d24aa4">tenuM2mTxPwrLevel</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Must be called after the initialization and before any connection request and can't be changed in runtime.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns M2M_SUCCESS for success and a negative value otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___w_l_a_n_enums.html#gac76a1f79185dcf95e7f0e82ba0d24aa4">tenuM2mTxPwrLevel</a> <a class="el" href="group__m2m__wifi.html#ga66f5bf5f84f898bdd4453f2717a3deb5" title="Synchronous API to initialize the WINC driver.">m2m_wifi_init</a> </dd></dl>

</div>
</div>
<a id="gacdde655475346d6c5d5983c8e159246e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacdde655475346d6c5d5983c8e159246e">&#9670;&nbsp;</a></span>m2m_wifi_start_provision_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_wifi_start_provision_mode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtstr_m2_m_a_p_config.html">tstrM2MAPConfig</a> *&#160;</td>
          <td class="paramname"><em>pstrM2MAPConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pcHttpServerDomainName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bEnableHttpRedirect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronous API for control of Wi-Fi provisioning functionality. </p>
<p>This function allows the application to start the WINC in 'provisioning mode', a special mode that triggers the WINC to create a Wi-Fi access point, DHCP server, and HTTP server.</p>
<p>The HTTP server presents a provisioning page to a connected client which lists the access points detected in the vicinity of the WINC, and allows one of these to be selected and any appropriate credentials to be entered. This allows a headless system to be provisioned (configured to connect with an access point).</p>
<p>Provisioning status is returned in an event <a class="el" href="group___w_l_a_n_enums.html#gga57466b36df595c593e7ccc9892e14b20a4b4a55c41771f106a578b7253c63dede">M2M_WIFI_RESP_PROVISION_INFO</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pstrAPConfig</td><td>AP configuration parameters as defined in <a class="el" href="structtstr_m2_m_a_p_config.html">tstrM2MAPConfig</a> configuration structure. If a NULL value is passed in, the call will result in a negative error M2M_ERR_FAIL.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pcHttpServerDomainName</td><td>Domain name of the HTTP Provision WEB server which others will use to load the provisioning Home page. The domain name can have one of the following 3 forms:<ul>
<li>1. "wincprov.com"</li>
<li>2. "http://wincprov.com"</li>
<li>3. "https://wincprov.com"</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>Forms 1 and 2 are equivalent, they will both start a plain http server, while form 3 will start a secure HTTP provisioning Session (HTTP over SSL connection).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bEnableHttpRedirect</td><td>A flag to enable/disable the HTTP redirect feature. If Secure provisioning is enabled (i.e. the server domain name uses "https" prefix) this flag is ignored (no meaning for redirect in HTTPS). Possible values are:<ul>
<li>Zero: DO NOT use HTTP Redirect. In this case, the associated device could open the provisioning page ONLY when the HTTP Provision URL of the WINC HTTP Server is correctly written on the browser.</li>
<li>Non-Zero: Use HTTP Redirect. In this case, all http traffic (<a href="http://URL">http://URL</a>) from the associated device (Phone, PC, etc) will be redirected to the WINC HTTP Provisioning Home page.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>A Wi-Fi notification callback of type <a class="el" href="group___w_l_a_n_callbacks.html#ga736f9be563605a41689b47de03de14d0">tpfAppWifiCb</a> MUST be implemented and registered at startup. Registering the callback is done through passing it to the initialization <a class="el" href="group__m2m__wifi.html#ga66f5bf5f84f898bdd4453f2717a3deb5">m2m_wifi_init</a> function.</li>
<li>The event <a class="el" href="group___w_l_a_n_enums.html#gga57466b36df595c593e7ccc9892e14b20a35767ad0217ab92b149bc77e79610d33">M2M_WIFI_RESP_CONN_INFO</a> must be handled in the callback to receive the requested connection info.</li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not use ".local" in the pcHttpServerDomainName.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns M2M_SUCCESS if the command has been successfully queued to the WINC and a negative value otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___w_l_a_n_callbacks.html#ga736f9be563605a41689b47de03de14d0" title="This is the main callback function for the Wi-Fi driver and is responsible for processing any M2M_WIF...">tpfAppWifiCb</a> <a class="el" href="group__m2m__wifi.html#ga66f5bf5f84f898bdd4453f2717a3deb5" title="Synchronous API to initialize the WINC driver.">m2m_wifi_init</a> <a class="el" href="group___w_l_a_n_enums.html#gga57466b36df595c593e7ccc9892e14b20a4b4a55c41771f106a578b7253c63dede">M2M_WIFI_RESP_PROVISION_INFO</a> <a class="el" href="group__m2m__wifi.html#ga580bb659506b1c6d5c0f7c35f79f5386" title="Synchronous API for terminating provisioning mode on the WINC.">m2m_wifi_stop_provision_mode</a> <a class="el" href="structtstr_m2_m_a_p_config.html" title="This structure holds the configuration parameters for the AP mode. It should be set by the applicatio...">tstrM2MAPConfig</a></dd></dl>
<h1><a class="anchor" id="WIFIExample1"></a>
Example</h1>
<p>The example demonstrates a code snippet for how provisioning is triggered and the response event received accordingly.</p>
<div class="fragment"></div><!-- fragment --> 
</div>
</div>
<a id="ga150576e8996172d1ae24a7070eb527c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga150576e8996172d1ae24a7070eb527c3">&#9670;&nbsp;</a></span>m2m_wifi_start_provision_mode_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_wifi_start_provision_mode_ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtstr_m2_m_a_p_mode_config.html">tstrM2MAPModeConfig</a> *&#160;</td>
          <td class="paramname"><em>pstrAPModeConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pcHttpServerDomainName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bEnableHttpRedirect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronous API for control of Wi-Fi provisioning functionality with extended options. </p>
<p>Asynchronous Wi-Fi provisioning function, which starts the WINC HTTP PROVISIONING mode. The function triggers the WINC to activate the Wi-Fi AP (HOTSPOT) mode with the passed configuration parameters and then starts the HTTP Provision WEB Server.</p>
<p>Provisioning status is returned in an event <a class="el" href="group___w_l_a_n_enums.html#gga57466b36df595c593e7ccc9892e14b20a4b4a55c41771f106a578b7253c63dede">M2M_WIFI_RESP_PROVISION_INFO</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pstrAPModeConfig</td><td>AP configuration parameters as defined in <a class="el" href="structtstr_m2_m_a_p_mode_config.html">tstrM2MAPModeConfig</a> configuration structure. A NULL value passed in, will result in a negative error M2M_ERR_FAIL.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pcHttpServerDomainName</td><td>Domain name of the HTTP Provision WEB server which others will use to load the provisioning Home page. The domain name can have one of the following 3 forms:<ul>
<li>1. "wincprov.com"</li>
<li>2. "http://wincprov.com"</li>
<li>3. "https://wincprov.com"</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>The forms 1 and 2 are equivalent, they both will start a plain http server, while form 3 will start a secure HTTP provisioning Session (HTTP over SSL connection).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bEnableHttpRedirect</td><td>A flag to enable/disable the HTTP redirect feature. If Secure provisioning is enabled (i.e. the server domain name uses "https" prefix) this flag is ignored (no meaning for redirect in HTTPS). Possible values are:<ul>
<li>ZERO value, which means DO NOT use HTTP Redirect. In this case, the associated device could open the provisioning page ONLY when the HTTP Provision URL of the WINC HTTP Server is correctly written on the browser.</li>
<li>Non-Zero value, means use HTTP Redirect. In this case, all http traffic (<a href="http://URL">http://URL</a>) from the associated device (Phone, PC, etc) will be redirected to the WINC HTTP Provisioning Home page.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>A Wi-Fi notification callback of type <a class="el" href="group___w_l_a_n_callbacks.html#ga736f9be563605a41689b47de03de14d0">tpfAppWifiCb</a> MUST be implemented and registered at startup. Registering the callback is done through passing it to the initialization <a class="el" href="group__m2m__wifi.html#ga66f5bf5f84f898bdd4453f2717a3deb5">m2m_wifi_init</a> function.</li>
<li>The event <a class="el" href="group___w_l_a_n_enums.html#gga57466b36df595c593e7ccc9892e14b20a35767ad0217ab92b149bc77e79610d33">M2M_WIFI_RESP_CONN_INFO</a> must be handled in the callback to receive the requested connection info.</li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>DO Not use ".local" in the pcHttpServerDomainName.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___w_l_a_n_callbacks.html#ga736f9be563605a41689b47de03de14d0" title="This is the main callback function for the Wi-Fi driver and is responsible for processing any M2M_WIF...">tpfAppWifiCb</a> <a class="el" href="group__m2m__wifi.html#ga66f5bf5f84f898bdd4453f2717a3deb5" title="Synchronous API to initialize the WINC driver.">m2m_wifi_init</a> <a class="el" href="group___w_l_a_n_enums.html#gga57466b36df595c593e7ccc9892e14b20a4b4a55c41771f106a578b7253c63dede">M2M_WIFI_RESP_PROVISION_INFO</a> <a class="el" href="group__m2m__wifi.html#ga580bb659506b1c6d5c0f7c35f79f5386" title="Synchronous API for terminating provisioning mode on the WINC.">m2m_wifi_stop_provision_mode</a> <a class="el" href="structtstr_m2_m_a_p_mode_config.html" title="AP Configuration.">tstrM2MAPModeConfig</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns M2M_SUCCESS if the command has been successfully queued to the WINC and a negative value otherwise.</dd></dl>
<h1><a class="anchor" id="WIFIExample1b"></a>
Example</h1>
<p>The example demonstrates a code snippet for how provisioning is triggered and the response event received accordingly.</p>
<div class="fragment"></div><!-- fragment --> 
</div>
</div>
<a id="ga580bb659506b1c6d5c0f7c35f79f5386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga580bb659506b1c6d5c0f7c35f79f5386">&#9670;&nbsp;</a></span>m2m_wifi_stop_provision_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_wifi_stop_provision_mode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronous API for terminating provisioning mode on the WINC. </p>
<p>This function will terminate any currently active provisioning mode on the WINC, returning the WINC to idle.</p>
<dl class="section pre"><dt>Precondition</dt><dd>An active provisioning session must be active before it is terminated through this function.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns M2M_SUCCESS for success and a negative value otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__m2m__wifi.html#gacdde655475346d6c5d5983c8e159246e" title="Asynchronous API for control of Wi-Fi provisioning functionality.">m2m_wifi_start_provision_mode</a> </dd></dl>

</div>
</div>
<a id="ga67de06e2707f6a56b62b1490c24f5a26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67de06e2707f6a56b62b1490c24f5a26">&#9670;&nbsp;</a></span>m2m_wifi_wps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_wifi_wps </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>u8TriggerType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pcPinNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronous API to engage the WINC Wi-Fi Protected Setup (enrollee) function. </p>
<p>This function can be called to make the WINC enter WPS (Wi-Fi Protected Setup) mode. The result is passed to the Wi-Fi notification callback with the event <a class="el" href="group___w_l_a_n_enums.html#gga064de09dec1d5e88ed8d075fa40f57dea092328f1505213c9ab290f1e2482d69e">M2M_WIFI_REQ_WPS</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">u8TriggerType</td><td>WPS Trigger method. This may be:<ul>
<li><a class="el" href="group___w_l_a_n_enums.html#gga5bbde63fb908694883507ec7295f74f6ae52305c62b5997a9f4f85b039062465c">WPS_PIN_TRIGGER</a> Push button method</li>
<li><a class="el" href="group___w_l_a_n_enums.html#gga5bbde63fb908694883507ec7295f74f6aa578860ada0f036843221e9a5e87d934">WPS_PBC_TRIGGER</a> Pin method</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pcPinNumber</td><td>Valid only if the u8TriggerType is <a class="el" href="group___w_l_a_n_enums.html#gga5bbde63fb908694883507ec7295f74f6ae52305c62b5997a9f4f85b039062465c">WPS_PIN_TRIGGER</a>, this parameter contains the PIN number. The number must follow the format as given in the WSC1.0 specification.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns M2M_SUCCESS if the command has been successfully queued to the WINC and a negative value otherwise.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is not allowed in AP modes.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>A Wi-Fi notification callback of type (<a class="el" href="group___w_l_a_n_callbacks.html#ga736f9be563605a41689b47de03de14d0">tpfAppWifiCb</a> MUST be implemented and registered at startup. Registering the callback is done through passing it to <a class="el" href="group__m2m__wifi.html#ga66f5bf5f84f898bdd4453f2717a3deb5">m2m_wifi_init</a>.</li>
<li>The event <a class="el" href="group___w_l_a_n_enums.html#gga064de09dec1d5e88ed8d075fa40f57dea092328f1505213c9ab290f1e2482d69e">M2M_WIFI_REQ_WPS</a> must be handled in the callback to receive the WPS status.</li>
<li>The WINC device MUST be in IDLE or STA mode. If AP or P2P mode is active, the WPS will not be performed.</li>
<li>The <a class="el" href="group__m2m__wifi.html#gae397199d8523f172b33309b82c34c2af">m2m_wifi_handle_events</a> MUST be called periodically to receive the responses in the callback.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___w_l_a_n_callbacks.html#ga736f9be563605a41689b47de03de14d0" title="This is the main callback function for the Wi-Fi driver and is responsible for processing any M2M_WIF...">tpfAppWifiCb</a> <a class="el" href="group__m2m__wifi.html#ga66f5bf5f84f898bdd4453f2717a3deb5" title="Synchronous API to initialize the WINC driver.">m2m_wifi_init</a> <a class="el" href="group___w_l_a_n_enums.html#gga064de09dec1d5e88ed8d075fa40f57dea092328f1505213c9ab290f1e2482d69e">M2M_WIFI_REQ_WPS</a> <a class="el" href="group___w_l_a_n_enums.html#ga5bbde63fb908694883507ec7295f74f6" title="This enum contains the WPS triggering methods.">tenuWPSTrigger</a> <a class="el" href="structtstr_m2_m_w_p_s_info.html" title="WPS Result.">tstrM2MWPSInfo</a></dd></dl>
<h1><a class="anchor" id="WIFIExample3"></a>
Example</h1>
<p>The code snippet shows an example of how Wi-Fi WPS is triggered .</p>
<div class="fragment"></div><!-- fragment --> 
</div>
</div>
<a id="gaf0a66c1111e19f90cd3b9227cdd5d5b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0a66c1111e19f90cd3b9227cdd5d5b8">&#9670;&nbsp;</a></span>m2m_wifi_wps_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_wifi_wps_disable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronous API that disables Wi-Fi Protected Setup mode in the WINC. </p>
<dl class="section pre"><dt>Precondition</dt><dd>WINC should be already in WPS mode using <a class="el" href="group__m2m__wifi.html#ga67de06e2707f6a56b62b1490c24f5a26">m2m_wifi_wps</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns M2M_SUCCESS if the command has been successfully queued to the WINC and a negative value otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__m2m__wifi.html#ga67de06e2707f6a56b62b1490c24f5a26" title="Asynchronous API to engage the WINC Wi-Fi Protected Setup (enrollee) function.">m2m_wifi_wps</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga6eab17798504ca5514ec11a639d91798"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6eab17798504ca5514ec11a639d91798">&#9670;&nbsp;</a></span>au8ethRcvBuf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* au8ethRcvBuf</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pointer to Receive Buffer of Ethernet Packet </p>

</div>
</div>
<a id="ga59bf2ba72a950da5b20edc7c0fe030d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59bf2ba72a950da5b20edc7c0fe030d3">&#9670;&nbsp;</a></span>bPrependDomain <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bPrependDomain</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines whether Domain is prepended or appended to UserName in EAP identity responses. true: Domain is prepended to UserName - [Domain][UserName]. false: Domain is appended to UserName - [UserName][Domain]. </p>

</div>
</div>
<a id="ga59bf2ba72a950da5b20edc7c0fe030d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59bf2ba72a950da5b20edc7c0fe030d3">&#9670;&nbsp;</a></span>bPrependDomain <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bPrependDomain</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines whether Domain is prepended or appended to UserName in EAP identity responses. true: Domain is prepended to UserName - [Domain][UserName]. false: Domain is appended to UserName - [UserName][Domain]. </p>

</div>
</div>
<a id="gac969c4653cf2a296c15b3316c441e99b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac969c4653cf2a296c15b3316c441e99b">&#9670;&nbsp;</a></span>bUnencryptedUserName <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bUnencryptedUserName</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines whether UserName or "anonymous" is sent (unencrypted) in the initial EAP identity response. Domain is sent in both cases. <br  />
 true: UserName is sent in the initial EAP identity response (not recommended). false: "anonymous" is sent in the initial EAP identity response. This setting is recommended for tunneled methods. MSCHAPv2 is always a tunneled method. </p>

</div>
</div>
<a id="gac969c4653cf2a296c15b3316c441e99b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac969c4653cf2a296c15b3316c441e99b">&#9670;&nbsp;</a></span>bUnencryptedUserName <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bUnencryptedUserName</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines whether UserName or "anonymous" is sent (unencrypted) in the initial EAP identity response. Domain is sent in both cases. <br  />
 true: UserName is sent in the initial EAP identity response (required for EAP-TLS). false: "anonymous" is sent in the initial EAP identity response. This setting is recommended for tunneled methods such as EAP-PEAP/TLS. </p>

</div>
</div>
<a id="ga400ea613d8260b3e87180cf0e2ab918c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga400ea613d8260b3e87180cf0e2ab918c">&#9670;&nbsp;</a></span>enuChannel</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___w_l_a_n_enums.html#ga2a91dd671e2672dba1a7ed45230f3a99">tenuM2mScanCh</a> enuChannel</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wi-Fi channel to connect on. If an appropriate AP cannot be found on this channel then connection fails. M2M_WIFI_CH_ALL may be used to allow scanning of all channels. </p>

</div>
</div>
<a id="ga04b95b307175b8ca1033a1597aa339b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04b95b307175b8ca1033a1597aa339b3">&#9670;&nbsp;</a></span>pfAppEthCb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___w_l_a_n_callbacks.html#ga5884506e89485befb4d0072be7f9be4f">tpfAppEthCb</a> pfAppEthCb</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback for Ethernet interface. </p>

</div>
</div>
<a id="ga26c229a7bbf756c2192c64fac8104af4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26c229a7bbf756c2192c64fac8104af4">&#9670;&nbsp;</a></span>pfAppWifiCb <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___w_l_a_n_callbacks.html#ga736f9be563605a41689b47de03de14d0">tpfAppWifiCb</a> pfAppWifiCb</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback for Wi-Fi notifications. </p>

</div>
</div>
<a id="ga26c229a7bbf756c2192c64fac8104af4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26c229a7bbf756c2192c64fac8104af4">&#9670;&nbsp;</a></span>pfAppWifiCb <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___w_l_a_n_callbacks.html#ga736f9be563605a41689b47de03de14d0">tpfAppWifiCb</a> pfAppWifiCb</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback for Wi-Fi notifications. </p>

</div>
</div>
<a id="ga287a132fe4ce1c882d1abcdad44a9a73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga287a132fe4ce1c882d1abcdad44a9a73">&#9670;&nbsp;</a></span>pu8Bssid</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* pu8Bssid</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pointer to BSSID (6 bytes). Optional (may be NULL). If present, this restricts the connection attempt to APs that have a matching BSSID. </p>

</div>
</div>
<a id="ga5e7c800089f87906813e765eed92fdfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e7c800089f87906813e765eed92fdfb">&#9670;&nbsp;</a></span>pu8Certificate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* pu8Certificate</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pointer to TLS client certificate corresponding to PrivateKey. This will be used during TLS client authentication. </p>

</div>
</div>
<a id="ga8fe5c84bf6a89322f1255f9a97456a86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8fe5c84bf6a89322f1255f9a97456a86">&#9670;&nbsp;</a></span>pu8Domain <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* pu8Domain</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pointer to Domain of authentication server (printable ASCII), including '@' or '\' separator character as appropriate. Use NULL if there is no domain information. The Domain will be either prepended or appended to the UserName, depending on the setting of field bPrependDomain. <br  />
 Example 1: if [Domain]is "@my_domain" and bPrependDomain is false, then the EAP identity response is "[UserName]@my_domain". <br  />
 Example 2: if [Domain]is "my_domain\" and bPrependDomain is true, then the EAP identity response is "my_domain\[UserName]". </p>

</div>
</div>
<a id="ga8fe5c84bf6a89322f1255f9a97456a86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8fe5c84bf6a89322f1255f9a97456a86">&#9670;&nbsp;</a></span>pu8Domain <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* pu8Domain</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pointer to Domain of authentication server (printable ASCII), including '@' or '\' separator character as appropriate. Use NULL if there is no domain information. The Domain will be either prepended or appended to the UserName, depending on the setting of field bPrependDomain. <br  />
 Example 1: if [Domain]is "@my_domain" and bPrependDomain is false, then the EAP identity response is "[UserName]@my_domain". <br  />
 Example 2: if [Domain]is "my_domain\" and bPrependDomain is true, then the EAP identity response is "my_domain\[UserName]". </p>

</div>
</div>
<a id="ga579fb13e7238b99432d79f833a7dfc66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga579fb13e7238b99432d79f833a7dfc66">&#9670;&nbsp;</a></span>pu8Passphrase</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* pu8Passphrase</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pointer to Passphrase (Printable ASCII). Must be NULL if PSK is provided instead. </p>

</div>
</div>
<a id="gae371d5cc2b4521e753d1cf3656005a83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae371d5cc2b4521e753d1cf3656005a83">&#9670;&nbsp;</a></span>pu8Password</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* pu8Password</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pointer to MSCHAPv2 Password (ASCII). This will be used during MSCHAPv2 authentication. </p>

</div>
</div>
<a id="ga3520c9f97099d36c89048c23b81b8ffc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3520c9f97099d36c89048c23b81b8ffc">&#9670;&nbsp;</a></span>pu8PrivateKey_Exp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* pu8PrivateKey_Exp</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pointer to PrivateKey exponent (raw data). This will be used during TLS client authentication. </p>

</div>
</div>
<a id="ga2dc2ceebbae6853d436ac193d2ed8210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2dc2ceebbae6853d436ac193d2ed8210">&#9670;&nbsp;</a></span>pu8PrivateKey_Mod</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* pu8PrivateKey_Mod</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pointer to PrivateKey modulus (raw data). This will be used during TLS client authentication. </p>

</div>
</div>
<a id="ga6c209e9fd0066f841e026d6ad36cf156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c209e9fd0066f841e026d6ad36cf156">&#9670;&nbsp;</a></span>pu8Psk</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* pu8Psk</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pointer to PSK, represented as an ASCII string (64 characters, representing 32 bytes). Must be NULL if Passphrase is provided instead. </p>

</div>
</div>
<a id="gae754bc1fbe103335162107d2555eea22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae754bc1fbe103335162107d2555eea22">&#9670;&nbsp;</a></span>pu8Ssid</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* pu8Ssid</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pointer to SSID. Required. </p>

</div>
</div>
<a id="ga7bbedda404b3d97df036782d489c0a6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7bbedda404b3d97df036782d489c0a6d">&#9670;&nbsp;</a></span>pu8UserName <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* pu8UserName</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pointer to UserName (ASCII). This will be sent (encrypted) in the tunneled EAP identity response (if applicable) and used during MSCHAPv2 authentication. If bUnencryptedUserName is true then it will also be sent (unencrypted) in the initial EAP identity response. </p>

</div>
</div>
<a id="ga7bbedda404b3d97df036782d489c0a6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7bbedda404b3d97df036782d489c0a6d">&#9670;&nbsp;</a></span>pu8UserName <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* pu8UserName</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pointer to UserName (ASCII). This will be sent (encrypted) in the tunneled EAP identity response. If bUnencryptedUserName is true then it will also be sent (unencrypted) in the initial EAP identity response. </p>

</div>
</div>
<a id="ga450c7d4c29c5ddfb9833ec0850bf0910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga450c7d4c29c5ddfb9833ec0850bf0910">&#9670;&nbsp;</a></span>pu8WepKey</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* pu8WepKey</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pointer to WEP Key, represented as an ASCII string. (10 or 26 characters, representing 5 or 13 bytes.) </p>

</div>
</div>
<a id="ga59cd226561744cd8589eb7d3b91f2bb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59cd226561744cd8589eb7d3b91f2bb9">&#9670;&nbsp;</a></span>strEthInitParam</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtstr_eth_init_param.html">tstrEthInitParam</a> strEthInitParam</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Structure to hold Ethernet interface parameters. </p>

</div>
</div>
<a id="ga3627f8e04acc0b6cdbfbddcf21e6d1bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3627f8e04acc0b6cdbfbddcf21e6d1bc">&#9670;&nbsp;</a></span>u16CertificateLen</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t u16CertificateLen</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Length of Certificate (in bytes). Permitted values are between 0 and <a class="el" href="group___w_l_a_n_defines.html#ga35273d5d0b3971b5df76735f81387b4b">M2M_AUTH_1X_CERT_LEN_MAX</a>. </p>

</div>
</div>
<a id="ga232485ba9f2825687f04342ed646d1c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga232485ba9f2825687f04342ed646d1c4">&#9670;&nbsp;</a></span>u16DataSize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t u16DataSize</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Size of the received data in bytes. </p>

</div>
</div>
<a id="ga631a045f636cbf5a32f7fdf4e2d6834d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga631a045f636cbf5a32f7fdf4e2d6834d">&#9670;&nbsp;</a></span>u16DomainLen <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t u16DomainLen</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Length of Domain (in ASCII characters), including '@' or '\' separator character as appropriate. Permitted values are such that u16DomainLen + u16UserNameLen is between 0 and <a class="el" href="group___w_l_a_n_defines.html#ga8db58760ceb25abdfd36855f9507837b">M2M_AUTH_1X_USER_LEN_MAX</a>. </p>

</div>
</div>
<a id="ga631a045f636cbf5a32f7fdf4e2d6834d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga631a045f636cbf5a32f7fdf4e2d6834d">&#9670;&nbsp;</a></span>u16DomainLen <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t u16DomainLen</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Length of Domain (in ASCII characters), including '@' or '\' separator character as appropriate. Permitted values are such that u16DomainLen + u16UserNameLen is between 0 and <a class="el" href="group___w_l_a_n_defines.html#ga8db58760ceb25abdfd36855f9507837b">M2M_AUTH_1X_USER_LEN_MAX</a>. </p>

</div>
</div>
<a id="ga6a2bca251ff02e16282d25b3198b02bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a2bca251ff02e16282d25b3198b02bc">&#9670;&nbsp;</a></span>u16ethRcvBufSize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t u16ethRcvBufSize</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Size of Receive Buffer for Ethernet Packet </p>

</div>
</div>
<a id="ga8dc5df15e08785d98f423ba7bcd28981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8dc5df15e08785d98f423ba7bcd28981">&#9670;&nbsp;</a></span>u16PasswordLen</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t u16PasswordLen</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Length of Password (in ASCII characters). Permitted values are between 0 and <a class="el" href="group___w_l_a_n_defines.html#ga4ea9615a1a8bc5a933a0c93568dfa095">M2M_AUTH_1X_PASSWORD_LEN_MAX</a>. </p>

</div>
</div>
<a id="ga700c7ef365b380b9478aea26af1a04ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga700c7ef365b380b9478aea26af1a04ff">&#9670;&nbsp;</a></span>u16PrivateKeyLen</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t u16PrivateKeyLen</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Length of PrivateKey_Mod (in bytes). Permitted values are between 0 and <a class="el" href="group___w_l_a_n_defines.html#ga84fa0c2ee00c8f97122d230ce32e8bb0">M2M_AUTH_1X_PRIVATEKEY_LEN_MAX</a>, typically 128 or 256. PrivateKey_Exp must be the same length as modulus, pre-padded with 0s if necessary. </p>

</div>
</div>
<a id="gae2b20fa12030589032bd8fe46b9e84c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2b20fa12030589032bd8fe46b9e84c1">&#9670;&nbsp;</a></span>u16RemainingDataSize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t u16RemainingDataSize</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Size of the remaining data bytes to be delivered to host. </p>

</div>
</div>
<a id="ga84a9ef217bc07bfd09d20b401547b3cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84a9ef217bc07bfd09d20b401547b3cf">&#9670;&nbsp;</a></span>u16UserNameLen <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t u16UserNameLen</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Length of UserName (in ASCII characters). Permitted values are such that u16DomainLen + u16UserNameLen is between 0 and <a class="el" href="group___w_l_a_n_defines.html#ga8db58760ceb25abdfd36855f9507837b">M2M_AUTH_1X_USER_LEN_MAX</a>. </p>

</div>
</div>
<a id="ga84a9ef217bc07bfd09d20b401547b3cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84a9ef217bc07bfd09d20b401547b3cf">&#9670;&nbsp;</a></span>u16UserNameLen <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t u16UserNameLen</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Length of UserName (in ASCII characters). Permitted values are such that u16DomainLen + u16UserNameLen is between 0 and <a class="el" href="group___w_l_a_n_defines.html#ga8db58760ceb25abdfd36855f9507837b">M2M_AUTH_1X_USER_LEN_MAX</a>. </p>

</div>
</div>
<a id="ga5df4e7912619fb37a4403ba45a54ea03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5df4e7912619fb37a4403ba45a54ea03">&#9670;&nbsp;</a></span>u8EthernetEnable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t u8EthernetEnable</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable Ethernet mode flag </p>

</div>
</div>
<a id="ga832373e5239b512421233481ed583b55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga832373e5239b512421233481ed583b55">&#9670;&nbsp;</a></span>u8KeyIndx</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t u8KeyIndx</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>WEP Key Index in the range 1 to 4. </p>

</div>
</div>
<a id="gaebc6c619e657cb1f135b454a36c1bd00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaebc6c619e657cb1f135b454a36c1bd00">&#9670;&nbsp;</a></span>u8KeySz</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t u8KeySz</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Size of WEP Key string. Permitted values are <a class="el" href="group___w_l_a_n_defines.html#ga4cfa81969980f3edea139634eeeb7ee1">WEP_40_KEY_STRING_SIZE</a> or <a class="el" href="group___w_l_a_n_defines.html#ga087f8be759b11ec0fe841d21e60367f5">WEP_104_KEY_STRING_SIZE</a>. </p>

</div>
</div>
<a id="ga92ec1391f4ae4ef43f7a87dd9bcdcbee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92ec1391f4ae4ef43f7a87dd9bcdcbee">&#9670;&nbsp;</a></span>u8PassphraseLen</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t u8PassphraseLen</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Length of Passphrase. Permitted values are between 8 and 63. This field is ignored if pu8Passphrase == NULL. </p>

</div>
</div>
<a id="gabed21391be96e9cccf3fcf3d72904c95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabed21391be96e9cccf3fcf3d72904c95">&#9670;&nbsp;</a></span>u8SsidLen</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t u8SsidLen</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Length of SSID in bytes. Permitted values are between 0 and 32. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
</body>
</html>
